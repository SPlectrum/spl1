{
  "headers": {
    "spl": {
      "package": {
        "name": "apps_boot.json"
      }
    }
  },
  "value": {
    "/boot/batches/deploy_install.txt": "spl/package/load -r install -d packages -f dirs_toplevel.json @@ spl/package/deploy -r . -d . -f dirs_toplevel.json\r\nspl/package/load -r install -d packages -f dirs_session.json @@ spl/package/deploy -r runtime/sessions -d client -f dirs_session.json\r\nspl/package/load -r install -d packages -f dirs_session.json @@ spl/package/deploy -r runtime/sessions -d test -f dirs_session.json\r\nspl/package/load -r install -d packages -f apps_test2.json @@ spl/package/deploy -r apps -d . -f apps_test2.json\r\nspl/package/load -r install -d packages -f apps_test-suite.json @@ spl/package/deploy -r apps -d . -f apps_test-suite.json\r\nspl/package/create -r install/modules -d . -f modules_spl.json @@ spl/package/deploy -r modules -d . -f modules_spl.json",
    "/boot/batches/release_to_install.txt": "spl/package/create -r ../release -d . -f release_files.json @@ spl/package/deploy -r .. -d spl -f release_files.json\r\nspl/package/create -r .. -d modules -f modules_spl.json @@ spl/package/deploy -r ../spl/install -d . -f modules_spl.json",
    "/boot/batches/remove_install.txt": "spl/package/load -r install -d packages -f dirs_toplevel.json @@ spl/package/remove -r . -d . -f dirs_toplevel.json",
    "/boot/modules/arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"top\" : [\r\n            { \"header\": \"SPlectrum Test App\" },\r\n            { \"content\": \"A client used to test the current package functionaltiy.\" }\r\n        ],\r\n        \"header\": [\r\n            { \"content\": \"Overview 1.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <options> <package>}\" }\r\n        ],\r\n        \"bottom\": [ \r\n            { \"content\": \"Project home: {underline https://github.com/SPlectrum/spl}\" } ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"test\", \"alias\": \"t\", \"type\": \"Boolean\", \"description\": \"test - parse commands but do not execute.\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"steps\", \"alias\": \"s\", \"type\": \"Number\", \"description\": \"TTL of the command execution.\"},\r\n        { \"name\": \"verbose\", \"alias\": \"v\", \"type\": \"Boolean\", \"description\": \"Do verbose output on completion.\"},\r\n        { \"name\": \"debug\", \"alias\": \"d\", \"type\": \"Boolean\", \"description\": \"Do debug output on completion.\"}\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/app.js": "//  name        app API Auxiliary Functions\r\n//  URI         spl/app/app\r\n//  type        Auxiliary Library\r\n//  description Auxiliary functions for the app API.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst parser = require('command-line-args');\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nexports.commandString = function ( splApp, current ) \r\n{\r\n    if ( current.part == -1 ) return splApp.value.input[`line_${current.line}`];\r\n    else  return splApp.value.input[`line_${current.line}`][`part_${current.part}`];\r\n}\r\n\r\nexports.parsed = function ( splApp, current ) \r\n{\r\n    if ( current.part == -1 ) return structuredClone ( splApp.value.parsed[`line_${current.line}`] );\r\n    else  return structuredClone ( splApp.value.parsed[`line_${current.line}`][`part_${current.part}`] );\r\n}\r\n\r\nexports.getDetails = function ( appRoot, moduleRoot, URI ) \r\n{\r\n    var prefix = \"\";\r\n    var getRoot = \"\", getDir = moduleRoot;\r\n    if ( URI.indexOf ( \"spl\" ) != 0 ) { getRoot = appRoot; getDir = \"modules\"; }\r\n    \r\n    if ( URI.length > 0 ) prefix = `${URI}_`;\r\n    const fileURI = `${(URI===\"\")?\"\":prefix}arguments.json`;\r\n    const getURI = `spl/blob.${spl.fURI ( getRoot, getDir.replace(\"../\",\"\"), fileURI )}`;\r\n    const wsURI = `spl/app.options.${spl.fURI ( fileURI )}`;\r\n    const args = [ { repo: getRoot, dir: getDir, file: fileURI, reference: [ wsURI ] } ];\r\n    return { URI: wsURI, getURI: getURI, args: args }\r\n}\r\n\r\nexports.getContentsDetails = function ( appRoot, moduleRoot, URI ) \r\n{\r\n//    var prefix = \"\";\r\n    var getRoot = \"\", getDir = moduleRoot;\r\n    if ( URI.indexOf ( \"spl\" ) != 0 ) { getRoot = appRoot; getDir = \"modules\"; }\r\n//    if ( URI.length > 0 ) prefix = `${URI;\r\n//    const fileURI = `${(URI===\"\")?\"\":prefix}arguments.json`;\r\n    const getURI = `spl/blob.${spl.URI ( getRoot, getDir.replace(\"../\",\"\"), URI )}`;\r\n    const wsURI = `spl/app.options.${spl.URI ( URI )}`;\r\n    const args = [ { repo: getRoot, dir: spl.URI( getDir, URI ), reference: [ wsURI ] } ];\r\n    return { URI: wsURI, getURI: getURI, args: args }\r\n}\r\n\r\nexports.getNext = function ( splApp ) \r\n{\r\n    var line = splApp.headers.spl.app.currentLine;\r\n    var part = splApp.headers.spl.app.currentPart;\r\n    part++;\r\n    if ( splApp.value.input[`line_${line}`] && splApp.value.input[`line_${line}`][`part_${part}`] ) return { line: line, part: part };\r\n    line++; part = 0;\r\n    if ( splApp.value.input[`line_${line}`] ) {\r\n        if ( splApp.value.input[`line_${line}`][`part_${part}`] === undefined ) part = -1;\r\n        return { line: line, part: part };\r\n    }\r\n    return { line: -1, part: -1 }\r\n}\r\n\r\nexports.reset = function ( splApp ) \r\n{\r\n    splApp.headers.spl.app.currentLine = -1;\r\n    splApp.headers.spl.app.currentPart = -1;\r\n}\r\n\r\nexports.setCurrent = function ( splApp, current ) \r\n{\r\n    splApp.headers.spl.app.currentLine = current.line;\r\n    splApp.headers.spl.app.currentPart = current.part;\r\n}\r\n\r\nexports.setParsed = function ( splApp, current, result ) \r\n{\r\n    if ( current.part == -1 ) splApp.value.parsed[`line_${current.line}`] = result;\r\n    else\r\n    {\r\n        if ( splApp.value.parsed[`line_${current.line}`] === undefined ) splApp.value.parsed[`line_${current.line}`] = {};\r\n        splApp.value.parsed[`line_${current.line}`][`part_${current.part}`] = result;\r\n    }\r\n}\r\n\r\nexports.splitAndTrim = function ( input )\r\n{\r\n    var output = [];\r\n    input = input.split(\" \");\r\n    for ( var i = 0; i < input.length; i++ ) if ( input[i].trim() != \"\") output.push(input[i]);\r\n    return output\r\n}\r\n\r\n// activates the option types\r\nfunction activateTypes (options) {\r\n    for(var i=0; i<options.length; i++)\r\n        if (options[i].type) {\r\n            switch(options[i].type) {\r\n                case \"BigInt\": options[i].type = BigInt; break;\r\n                case \"Boolean\": options[i].type = Boolean; break;\r\n                case \"Number\": options[i].type = Number; break;\r\n                case \"String\": options[i].type = String; break;\r\n            }\r\n        }\r\n    return options;\r\n}\r\nexports.activateTypes = activateTypes;\r\n\r\nexports.getChildOptions = function ( input, parent )\r\n{\r\n\r\n}\r\n\r\n/*\r\n// getCommandOptions \r\nexports.getHelpSection = function ( parseOptions, command ) {\r\n    var parts = command.split(\"/\");\r\n    if ( parts[0] === \"\" ) {\r\n        var packages = [];\r\n        for( key in parseOptions.packages ) packages.push ( { name: parseOptions.packages[key].header[0].header, summary: parseOptions.packages[key].header[1].content } );\r\n        var packageList =   {\r\n            header: 'Package List',\r\n            content: packages\r\n        }\r\n        return { \r\n            header: parseOptions.header, \r\n            options: { optionList: activateTypes ( structuredClone ( parseOptions.options ) ) },\r\n            subList: packageList\r\n        };\r\n    } else if ( parts.length == 1 ) {\r\n        var section = parseOptions.packages[parts[0]]\r\n        var apis = [];\r\n        for( key in section.apis ) apis.push ( { name: section.apis[key].header[0].header, summary: section.apis[key].header[1].content } );\r\n        var apiList =   {\r\n            header: 'API List',\r\n            content: apis\r\n        }\r\n        return {\r\n            header: section.header, \r\n            options: { optionList: activateTypes ( structuredClone ( section.options ) ) },\r\n            subList: apiList\r\n        };\r\n    } else if ( parts.length == 2 ) {\r\n        var section = parseOptions.packages[parts[0]].apis[parts[1]]\r\n        var methods = [];\r\n        for( key in section.methods ) methods.push ( { name: section.methods[key].header[0].header, summary: section.methods[key].header[1].content } );\r\n        var methodList =   {\r\n            header: 'Method List',\r\n            content: methods\r\n        }\r\n        return {\r\n            header: section.header, \r\n            options: { optionList: activateTypes ( structuredClone ( section.options ) ) },\r\n            subList: methodList\r\n        }\r\n    } else if ( parts.length == 3 ) {\r\n        var section = parseOptions.packages[parts[0]].apis[parts[1]].methods[parts[2]]\r\n        return {\r\n            header: section.header, \r\n            options: { optionList: activateTypes ( structuredClone ( section.options ) ) }\r\n        }\r\n    }\r\n}\r\n\r\n// getCommandOptions \r\nexports.getOptions = function ( parseOptions, command ) {\r\n    var parts = command.split(\"/\");\r\n    if ( parts[0] === \"\" ) return activateTypes ( structuredClone ( parseOptions.options ) );\r\n    else if ( parts.length == 1 )  return activateTypes ( structuredClone ( parseOptions.packages[parts[0]].options ) );\r\n    else if ( parts.length == 2 )  return activateTypes ( structuredClone ( parseOptions.packages[parts[0]].apis[parts[1]].options ) );\r\n    else if ( parts.length == 3 )  return activateTypes ( structuredClone ( parseOptions.packages[parts[0]].apis[parts[1]].methods[parts[2]].options ) );\r\n\r\n}\r\n\r\n// exists \r\nexports.exists = function ( parseOptions, command ) {\r\n    var parts = command.split(\"/\");\r\n    if ( parts[0] === \"\" ) return {};\r\n    else if ( parts.length == 1 )  return parseOptions.packages[parts[0]];\r\n    else if ( parts.length == 2 )  return parseOptions.packages[parts[0]].apis[parts[1]];\r\n    else if ( parts.length == 3 )  return parseOptions.packages[parts[0]].apis[parts[1]].methods[parts[2]];\r\n}\r\n*/\r\n// parse commandline section\r\nexports.parse = function (args, definitions) {\r\n    if(definitions === undefined) definitions = [{ name: 'command', defaultOption: true }];\r\n    return parser(definitions, { stopAtFirstUnknown: true, argv: args });\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n",
    "/boot/modules/spl/app/create.js": "//  name        Create\r\n//  URI         spl/app/create\r\n//  type        API Method\r\n//  description This action create an action from a batch of commands\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_create (input) { \r\n    console.log ( \"spl/app/create is not implemented yet.\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/create_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/create\" },\r\n            { \"content\": \"Creates an action from a batch of commands.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/ceate <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"api\", \"alias\": \"a\", \"description\": \"The API of the method to be created.\" },\r\n        { \"name\": \"method\", \"alias\": \"m\", \"description\": \"The method name to be created.\" },\r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file containing the batch of commands create the action from. It must reside in the batches folder.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/exec.js": "//  name        Exec\r\n//  URI         spl/app/exec\r\n//  type        API Method\r\n//  description This action reads commands from a file and executes them.\r\n//              Creates a pipeline that first reads the file, then processes the commands.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_exec (input)\r\n{\r\n    // Set the appRoot configuration\r\n    const appRoot = spl.action ( input, \"appRoot\" );\r\n    spl.setConfig ( input, \"spl/app\", \"appRoot\", appRoot );\r\n    \r\n    // Get file parameters from action configuration\r\n    const filePath = spl.action ( input, \"file\" );\r\n    \r\n    // Create a pipeline that first reads the file, then processes the commands\r\n    spl.wsSet(input, \"spl/execute.set-pipeline\", {\r\n        headers: {\r\n            spl: {\r\n                execute: {\r\n                    pipeline: [\r\n                        {\r\n                            action: \"spl/app/process-file\",\r\n                            \"spl/app/process-file\": {\r\n                                file: filePath,\r\n                                repo: appRoot,\r\n                                dir: \"batches\"\r\n                            }\r\n                        },\r\n                        { action: \"spl/app/prepare\" },\r\n                        { action: \"spl/app/parse\" },\r\n                        { action: \"spl/app/pipeline\" },\r\n                        { action: \"spl/app/finalise\" }\r\n                    ]\r\n                }\r\n            }\r\n        },\r\n        value: {}\r\n    });\r\n    spl.gotoExecute ( input, \"spl/execute/set-pipeline\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/exec_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/exec\" },\r\n            { \"content\": \"Executes a batch file of commands.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/exec <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file containing the batch of commands to execute. It must reside in the batches folder.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/finalise.js": "//  name        Pipeline\r\n//  URI         spl/app/finalise\r\n//  type        API Method\r\n//  description Prepares execution of batch based on global settings\r\n//              API internal command\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst app = require(\"./app.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_finalise (input)\r\n{ \r\n    // current implementation executes the batch within the same execution record - no spawning\r\n    const splApp = spl.wsRef ( input, \"spl/app\" );\r\n    if ( splApp.global.consoleMode ) spl.setContext( input, \"consoleMode\", splApp.global.consoleMode );\r\n\r\n    // if help required, add to the pipeline\r\n    if ( splApp.global.help.length > 0 ) splApp.pipeline.push ( { action: \"spl/app/help\", \"spl/app/help\": splApp.global.help } );\r\n\r\n    // create sp/execute/set-pipeline\r\n    if ( splApp.pipeline.length > 0 ) spl.wsSet(input, \"spl/execute.set-pipeline\", { headers: { spl: { execute: { pipeline: splApp.pipeline } } }, value: {} });\r\n\r\n        // complete request if it is parseOnly\r\n    if ( splApp.global.parseOnly ) spl.completed ( input );\r\n    else spl.gotoExecute ( input, \"spl/execute/set-pipeline\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/finalise_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/pipeline\" },\r\n            { \"content\": \"Internal action. Creates execution pipelines of a batch of commands that was parsed by spl/app/parse. It expects its input in the spl/app workspace entry.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/pipeline <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/help.js": "//  name        Help\r\n//  URI         spl/app/help\r\n//  type        API Method\r\n//  description The help function of the app API\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst app = require(\"./app.js\")\r\nconst help = require(\"command-line-usage\");\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_help (input) \r\n{ \r\n    const appRoot = spl.action ( input, \"appRoot\");\r\n    const moduleRoot = spl.context ( input, \"modules\" );\r\n    const helpURIs = spl.action ( input );\r\n    helpURIs.sort();\r\n    if ( helpURIs[0] != \"\" ) helpURIs.unshift ( \"\" );\r\n    console.log ( helpURIs );\r\n\r\n    var currentArgs = app.getDetails ( appRoot, moduleRoot, helpURIs[0] );\r\n    if(!spl.wsExists ( input, currentArgs.getURI, \"spl/blob/get\", currentArgs.args, true )) return;\r\n    var helpData = [];\r\n    var parseOptions = spl.wsRef ( input, currentArgs.URI );\r\n    helpData = helpData.concat ( parseOptions.headers.top );\r\n    const bottom = helpData.concat ( parseOptions.headers.bottom );\r\n\r\n    for ( var i = 0; i < helpURIs.length; i++ )\r\n    {\r\n        currentArgs = app.getDetails ( appRoot, moduleRoot, helpURIs[i] );\r\n        if(!spl.wsExists ( input, currentArgs.getURI, \"spl/blob/get\", currentArgs.args, true )) return;\r\n        parseOptions = spl.wsRef ( input, currentArgs.URI );\r\n        helpData = helpData.concat ( parseOptions.headers.header );\r\n        helpData = helpData.concat ([ { header: \"Options\", optionList: parseOptions.value } ]);\r\n/*        if ( i > 0 ) \r\n        {\r\n            currentArgs = app.getContentsDetails ( appRoot, moduleRoot, helpURIs[i] );\r\n            if(!spl.wsExists ( input, currentArgs.getURI, \"spl/blob/contents\", currentArgs.args, true )) return;\r\nconsole.dir ( currentArgs, {depth:10} )\r\n//            parseOptions = spl.wsRef ( input, currentArgs.URI );\r\n        }*/\r\n    }\r\n\r\n    helpData = helpData.concat ( bottom );\r\n    console.log(help(helpData))\r\n\r\n    /*\r\n    var getDetails = app.getDetails ( appRoot, moduleRoot, \"\" );\r\n    if(!spl.wsExists ( input, getDetails.getURI, \"spl/blob/get\", getDetails.args, true )) return;\r\n    var parseOptions = app.activateTypes( spl.wsRef ( input, getDetails.URI ).value );\r\n    \r\n\r\n    const helpRequests = spl.action( input );\r\n    const splCommand = spl.wsRef ( input, \"spl/command\" );\r\n    const parserOptionsURI = spl.fURI(\"spl/command\", splCommand.headers.spl.command.parser.file);\r\n    const parserOptions = spl.wsRef ( input, parserOptionsURI ).value;\r\n    var helpData = [];\r\n    helpData = helpData.concat ( parserOptions.top );\r\n    for ( var i=0; i < helpRequests.length; i++ ) {\r\n        var section = command.getHelpSection ( parserOptions, helpRequests[i] );\r\n        helpData = helpData.concat ( section.header );\r\n        if ( section.options ) helpData.push ( section.options );\r\n        if ( section.subList ) helpData.push ( section.subList );\r\n    }\r\n    helpData = helpData.concat ( parserOptions.bottom );\r\n    console.log(help(helpData))\r\n*/\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/help_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/help\" },\r\n            { \"content\": \"Show the help information for the items requested.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/help <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"items\", \"alias\": \"i\", \"type\": \"String\", \"multiple\": true, \"defaultOption\": true, \"description\": \"The list of items help is required for.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/index.js": "//  name        app API\r\n//  URI         spl/app\r\n//  type        API Module\r\n//  description This API contains the common app methods\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/parse.js": "//  name        Parse\r\n//  URI         spl/app/parse\r\n//  type        API Method\r\n//  description This action runs a JS script\r\n//              API internal command\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst app = require(\"./app.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_parse (input) { \r\n\r\n    // test retrieving lookups\r\n    const appRoot = spl.action ( input, \"appRoot\");\r\n    const moduleRoot = spl.context ( input, \"modules\" );\r\n    const splApp = spl.wsRef ( input, \"spl/app\" );\r\n    // load folder contents\r\n    var TTL = 100;\r\n    while ( TTL-- > 0 ) {\r\n\r\n        // get next line, if line = -1 then no next and break - it is finished\r\n        const current = app.getNext ( splApp ); if ( current.line < 0 ) break;\r\n        var result = { _unknown: app.commandString ( splApp, current ) };\r\n        var parsed = {};\r\n\r\n        // next parse command / argument pairs until finished\r\n        var getDetails = app.getDetails ( appRoot, moduleRoot, \"\" );\r\n        if(!spl.wsExists ( input, getDetails.getURI, \"spl/blob/get\", getDetails.args, true )) return;\r\n        var parseOptions = app.activateTypes( spl.wsRef ( input, getDetails.URI ).value );\r\n        // first parse global arguments\r\n        result = app.parse ( result._unknown, parseOptions );\r\n        parsed [ \"\" ] = result;\r\n\r\n        // update parsed (if not already done)\r\n        var counter = 3, commandAction = \"\";\r\n        while ( counter-- > 0 && result._unknown ) \r\n        {\r\n            result = app.parse(result._unknown);\r\n            commandAction += (commandAction === \"\") ? result.command : \"/\" + result.command;\r\n            var getDetails = app.getDetails ( appRoot, moduleRoot, commandAction );\r\n            if ( result._unknown === undefined ) result._unknown = [];\r\n            if(!spl.wsExists ( input, getDetails.getURI, \"spl/blob/get\", getDetails.args, true )) return;\r\n            parseOptions = app.activateTypes( spl.wsRef ( input, getDetails.URI ).value );\r\n            result = app.parse ( result._unknown, parseOptions );\r\n            parsed [ commandAction ] = result;\r\n            if ( !( result._unknown && counter > 0 ) ) break;   \r\n        }\r\n\r\n        // update parsing state\r\n        app.setParsed ( splApp, current, parsed );\r\n        app.setCurrent ( splApp, current );\r\n    }\r\n\r\n    if( TTL < 1 ) return spl.throwError ( input, \"Parser ran out of steps when parsing.\")\r\n    spl.completed ( input );\r\n/*  required when validating batch prior to execution, not in this implementation\r\n    // get folder contents of actions, batches and scripts folders\r\n    const appRoot = spl.action ( input, \"appRoot\" );\r\n    const actions = { repo: appRoot, dir: \"actions\", reference: [ \"spl/app.actions\" ] };\r\n    const batches = { repo: appRoot, dir: \"batches\", reference: [ \"spl/app.batches\" ] };\r\n    const scripts = { repo: appRoot, dir: \"scripts\", reference: [ \"spl/app.scripts\" ] };\r\n    const args = [ actions, batches, scripts ];\r\n    spl.gotoExecute ( input, \"spl/blob/contents\", args );\r\n*/\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/parse_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/parse\" },\r\n            { \"content\": \"Internal action. Parses a batch of commands that was prepared by spl/app/prepare. It expects its input in the spl/app workspace entry.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/pipeline <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/pipeline.js": "//  name        Pipeline\r\n//  URI         spl/app/pipeline\r\n//  type        API Method\r\n//  description Creates pipelines from the parsed commands\r\n//              API internal command\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst app = require(\"./app.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_pipeline (input)\r\n{ \r\n    // current implementation executes the batch within the same execution record - no spawning\r\n    const splApp = spl.wsRef ( input, \"spl/app\" );\r\n    app.reset ( splApp );\r\n    var TTL = 100\r\n    splApp.pipeline = [];\r\n    splApp.global = { help: [] };\r\n    while ( TTL-- > 0 ) \r\n    {\r\n        // get next line, if line = -1 then no next and break - it is finished\r\n        const current = app.getNext ( splApp ); if ( current.line < 0 ) break;\r\n        const parsed = app.parsed ( splApp, current );\r\n        for ( var key in parsed )\r\n        {\r\n            // first process global arguments\r\n            // current implementation sets the global argument for the whole batch\r\n            var steps;\r\n            if ( key === \"\" ) \r\n            {\r\n                if ( !(parsed[key].test === undefined ) ) splApp.global.parseOnly = true;\r\n                if ( parsed[key].steps > 0 ) steps = parsed[key].steps;\r\n                if ( parsed[key].help ) splApp.global.help.push ( key );\r\n                if ( parsed[key].debug ) splApp.global.consoleMode = \"debug\";\r\n                else if ( parsed[key].verbose ) splApp.global.consoleMode = \"verbose\";\r\n            }\r\n            else\r\n            {\r\n                if ( parsed[key]._unknown != undefined ) delete parsed[key]._unknown;\r\n                // help request is added to spl/app/help action\r\n                if ( parsed[key].help ) splApp.global.help.push ( key );\r\n                else \r\n                {\r\n                    const request = { action: key };\r\n                    var args; for ( var k in parsed[key] ) { args = parsed[key]; break; };\r\n                    // if steps were set, add to the first request in the pipeline\r\n                    if ( steps ) { if ( args === undefined ) args = {}; args.TTL = steps; steps = undefined; }\r\n                    if ( args != undefined ) request[key] = args;\r\n                    splApp.pipeline.push ( request );\r\n                }\r\n            }\r\n        }\r\n        app.setCurrent ( splApp, current );\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/pipeline_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/finalise\" },\r\n            { \"content\": \"Internal action. Prepares execution of batch based on global settings. It expects its input in the spl/app workspace entry.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/finalise <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/prepare.js": "//  name        Prepare\r\n//  URI         spl/app/prepare\r\n//  type        API Method\r\n//  description This action prepares the command line entry for parsing.\r\n//              API internal command\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst app = require(\"./app.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_prepare (input) { \r\n\r\n    // prepare the batch input for parsing\r\n    // split into lines and where needed line parts\r\n    var batchInput = structuredClone(spl.action ( input, \"batch\" ));\r\n    const batchPrepared = {};\r\n    if ( Array.isArray ( batchInput ) ) batchInput = batchInput.join(\" \");\r\n    batchInput = batchInput.replaceAll ( \"\\r\", \"\" );\r\n    batchInput = batchInput.split(\"\\n\");\r\n    for ( var i = 0; i < batchInput.length; i++ ) \r\n    {\r\n        var batchLine = {};\r\n        if ( batchInput[i].indexOf ( \"@@\" ) > -1 ) \r\n        {\r\n            batchInput[i] = batchInput[i].split ( \"@@\" );\r\n            for( var j = 0; j < batchInput[i].length; j++) batchLine[`part_${j}`] = app.splitAndTrim ( batchInput[i][j] );\r\n        }\r\n        else batchLine = app.splitAndTrim ( batchInput[i] );\r\n        batchPrepared[`line_${i}`] = batchLine;\r\n    }\r\n\r\n    // create the workspace spl/app entry\r\n    const previous = spl.wsRef ( input, \"spl/app\" );\r\n    const prepared = { \r\n        headers: { spl: { app: { currentLine: -1, currentPart: -1 } } }, \r\n        value: { batch: spl.action ( input, \"batch\" ), input: batchPrepared, parsed: {}, options: {} } };\r\n    if ( previous != undefined ) prepared.value.options = previous.value.options;\r\n    spl.wsSet ( input, \"spl/app\", prepared );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/prepare_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/prepare\" },\r\n            { \"content\": \"Internal action.  Prepares teh raw multiline commandline input for parsing.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/prepare <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"batch\", \"alias\": \"b\", \"description\": \"The batch of commands..\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/process-file.js": "//  name        Process File\r\n//  URI         spl/app/process-file\r\n//  type        API Method\r\n//  description Reads commands from a specified file and stores them for processing.\r\n//              This method only reads the file, it does not process the commands.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_process_file (input)\r\n{ \r\n    // Get the file path from action configuration\r\n    const filePath = spl.action ( input, \"file\" );\r\n    const fileRepo = spl.action ( input, \"repo\" ) || spl.action ( input, \"appRoot\" );\r\n    const fileDir = spl.action ( input, \"dir\" ) || \"batches\";\r\n    \r\n    // Check if we need to read the file first\r\n    const fileUri = spl.URI ( fileRepo, fileDir, filePath );\r\n    if ( !spl.wsExists ( input, `spl/blob.${spl.fURI(fileUri)}`, \"spl/blob/get\", {\r\n        repo: fileRepo,\r\n        dir: fileDir,\r\n        file: filePath,\r\n        encoding: \"text\"\r\n    }, true ) ) return;\r\n    \r\n    // Get the file contents from workspace and store it as batch for processing\r\n    const fileContents = spl.wsGet ( input, `spl/blob.${spl.fURI(fileUri)}` ).value;\r\n    // Use spl.setConfig to pass the batch to spl/app/process\r\n    spl.setConfig ( input, \"spl/app/prepare\", \"batch\", fileContents );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////",
    "/boot/modules/spl/app/process-file_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/process-file\" },\r\n            { \"content\": \"Reads commands from a specified file and stores them for processing.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/process-file <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file containing the batch of commands to read.\" },\r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository where the file is located (defaults to appRoot).\" },\r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory where the file is located (defaults to 'batches').\" },\r\n        { \"name\": \"appRoot\", \"alias\": \"a\", \"description\": \"The root folder of the app.\" }\r\n    ]\r\n}",
    "/boot/modules/spl/app/process.js": "//  name        Process\r\n//  URI         spl/app/process\r\n//  type        API Method\r\n//  description This is the entry action to prepare, parse and execute the command line string.\r\n//              API internal command\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_process (input)\r\n{ \r\n    spl.setConfig ( input, \"spl/app\", \"appRoot\", spl.action ( input, \"appRoot\" ) );\r\n    spl.wsSet(input, \"spl/execute.set-pipeline\", {\r\n        headers: {\r\n            spl: {\r\n                execute: {\r\n                    pipeline: [\r\n                        { action: \"spl/app/prepare\", \"spl/app/prepare\": { batch: spl.action ( input, \"batch\" ) } },\r\n                        { action: \"spl/app/parse\" },\r\n                        { action: \"spl/app/pipeline\" },\r\n                        { action: \"spl/app/finalise\" }\r\n                    ]\r\n                }\r\n            }\r\n        }, \r\n        value: {}\r\n    });\r\n    spl.gotoExecute ( input, \"spl/execute/set-pipeline\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/process_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/process\" },\r\n            { \"content\": \"Internal action. Process a multiline commandline input. This is the entry command for app execution.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/process <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"appRoot\", \"alias\": \"a\", \"description\": \"The root folder of the app.\" },\r\n        { \"name\": \"batch\", \"alias\": \"b\", \"description\": \"The batch of commands to be processed / executed.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/reset.js": "//  name        Reset\r\n//  URI         spl/app/reset\r\n//  type        API Method\r\n//  description This action resets an app configuration to its default\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_reset (input) \r\n{ \r\n    console.log ( \"spl/app/reset is not implemented yet.\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/reset_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/reset\" },\r\n            { \"content\": \"Resets an app configuration keyvalue to its default.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/reset <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"key\", \"alias\": \"k\", \"description\": \"The key of the configuration keyvalue.\" },\r\n        { \"name\": \"value\", \"alias\": \"v\", \"description\": \"The value of the configuration keyvalue.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/run.js": "//  name        Run\r\n//  URI         spl/app/run\r\n//  type        API Method\r\n//  description This action runs a JS script\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_run (input) \r\n{ \r\n    console.log ( \"spl/app/run is not implemented yet.\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/run_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/run\" },\r\n            { \"content\": \"Runs a JS script file.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/exec <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file containing the JS scripts to run. It must reside in the batches folder.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/set.js": "//  name        Set\r\n//  URI         spl/app/set\r\n//  type        API Method\r\n//  description This action sets app configurations\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_set (input) \r\n{ \r\n    console.log ( \"spl/app/set is not implemented yet.\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/set_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/set\" },\r\n            { \"content\": \"Sets an app configuration keyvalue.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/set <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"key\", \"alias\": \"k\", \"description\": \"The key of the configuration keyvalue.\" },\r\n        { \"name\": \"value\", \"alias\": \"v\", \"description\": \"The value of the configuration keyvalue.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app/wrap.js": "//  name        Wrap\r\n//  URI         spl/app/wrap\r\n//  type        API Method\r\n//  description This action wraps a JS script into an action\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_app_wrap (input) \r\n{ \r\n    console.log ( \"spl/app/wrap is not implemented yet.\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/app/wrap_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app/wrap\" },\r\n            { \"content\": \"Wraps a JS script into an action.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app/wrap <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"api\", \"alias\": \"a\", \"description\": \"The API of the method to be created.\" },\r\n        { \"name\": \"method\", \"alias\": \"m\", \"description\": \"The method name to be created.\" },\r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file containing the JS script to wrap into an action. It must reside in the scripts folder.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/app_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/app\" },\r\n            { \"content\": \"The common API available to all apps. It contains a mixture of external and internal actions. The internal actions take care of command parsing and execution.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/app <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/avro/index.js": "//  name        The spl/avro API\r\n//  URI         spl/avro\r\n//  type        API Module\r\n//  description The avro API manages AVRO in memeory BLOB and file containers.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/avro_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/avro\" },\r\n            { \"content\": \"The API for AVRO specific actions.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/avro <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/blob/blob.js": "//  name        BLOB Auxiliary Functions\r\n//  URI         spl/blob/blob\r\n//  type        Auxiliary Library\r\n//  description Contains common filesystem functions used by the blob API\r\n//              There is a mixture of synchronous and asynchronous methods.\r\n//              The initial implementation of the data layer is filesystem only.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// adds a full dir path \r\nexports.addDir = function ( input, spl, dirPath ) {\r\n    spl.history ( input, `addDir ${dirPath}` );\r\n    fs.mkdirSync ( dirPath, { recursive: true } );\r\n}\r\n\r\n// returns an array of files and dirs - synchronous\r\nexports.dirContents = function ( dirPath ) {\r\n    return fs.readdirSync(dirPath);    \r\n}\r\n\r\n// copy file from source to destination\r\nexports.copyFile = function ( input, spl, fromFilePath, toFilePath ) {\r\n    fs.copyFile ( fromFilePath, toFilePath, function (err) {\r\n        if ( err ) spl.history ( input, `ERROR - async - copy file from ${fromFilePath} to ${toFilePath} - ${err.toString()}` ); \r\n        else spl.history ( input, `async - COMPLETED copy file from ${fromFilePath} to ${toFilePath}` );\r\n    });\r\n}\r\n\r\n// delete file asynchronously, in the background - asynchronous\r\nexports.deleteFile = function ( input, spl, filePath ) {\r\n    fs.unlink( filePath, ( err ) => { \r\n        if ( err ) spl.history ( input, `ERROR - async - delete file ${filePath} - ${err.toString()}` ); \r\n        else spl.history ( input, `async - COMPLETED delete file ${filePath}` );\r\n    });\r\n}\r\n\r\n// get file, synchronous\r\nexports.getFile = function ( filePath ) { return fs.readFileSync ( filePath, 'utf8' ); }\r\n\r\n// move file asynchronously, in the backgroud - asynchronous\r\nexports.moveFile = function ( input, spl, fromFilePath, toFilePath ) {\r\n    fs.rename ( fromFilePath, toFilePath, function ( err ) {\r\n        if ( err ) spl.history ( input, `ERROR - async - move file from ${fromFilePath} to ${toFilePath} - ${err.toString()}` ); \r\n        else spl.history ( input, `async - COMPLETED move file from ${fromFilePath} to ${toFilePath}` );\r\n    });\r\n}\r\n\r\n// create a properly formatted file path\r\nexports.path = function ( ...args ) { return path.join ( ...args ); }\r\n\r\n// put file asynchronously, in the background - asynchronous\r\nexports.putFile = function ( input, spl, filePath, contents ) {\r\n    fs.writeFile ( filePath, contents, ( err ) => {\r\n        if ( err ) spl.history ( input, `ERROR - async - put file ${filePath} - ${err.toString()}` ); \r\n        else spl.history ( input, `async - COMPLETED put file ${filePath}` );\r\n     });\r\n}\r\n\r\n// create a properly formatted file path\r\nexports.setLocation = function ( location )\r\n{\r\n    if( Array.isArray(location) ) {\r\n        const newLocation = {};\r\n        newLocation.repo = location[0];\r\n        newLocation.dir = location[1];\r\n        newLocation.file = location[2];\r\n        location = newLocation; \r\n    } else if ( typeof location === \"string\" ) {\r\n        var uri = location.split(\"/\");\r\n        location = {};\r\n        location.file = (uri[uri.length-1].indexOf(\".\")>0) ? uri.pop() : undefined;\r\n        if ( (\"apps data packages\").includes(uri[0])) { location.repo = uri.slice(0,2).join(\"/\"); location.dir = uri.slice(2).join(\"/\"); }\r\n        else if ( uri[2] === \"data\" ) { location.repo = uri.slice(0,3).join(\"/\"); location.dir = uri.slice(3).join(\"/\"); }\r\n        else if ( uri[3] === \"data\" ) { location.repo = uri.slice(0,4).join(\"/\"); location.dir = uri.slice(4).join(\"/\"); }\r\n        else { location.repo = uri.join(\"/\"); location.dir = \"\"; }\r\n    } else if( Array.isArray(location.path) ) {\r\n        location.repo = location.path[0];\r\n        location.dir = location.path[1];\r\n        location.file = location.path[2]; \r\n    } else if ( typeof location.uri === \"string\" ) {\r\n        var uri = location.uri.split(\"/\");\r\n        location.file = (uri[uri.length-1].indexOf(\".\")>0) ? uri.pop() : undefined;\r\n        if ( (\"apps data packages\").includes(uri[0])) { location.repo = uri.slice(0,2).join(\"/\"); location.dir = uri.slice(2).join(\"/\"); }\r\n        else if ( uri[2] === \"data\" ) { location.repo = uri.slice(0,3).join(\"/\"); location.dir = uri.slice(3).join(\"/\"); }\r\n        else if ( uri[3] === \"data\" ) { location.repo = uri.slice(0,4).join(\"/\"); location.dir = uri.slice(4).join(\"/\"); }\r\n        else { location.repo = uri.join(\"/\"); location.dir = \"\"; }\r\n    }\r\n    return location;\r\n}\r\n",
    "/boot/modules/spl/blob/contents.js": "//  name        Gets the contents of a folder\r\n//  URI         spl/blob/contents\r\n//  type        API Method\r\n//  description Gets the contents of a folder.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst blob = require(\"./blob.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_blob_contents ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var sources = spl.action ( input );\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i] = blob.setLocation(sources[i]);\r\n        const contents = blob.dirContents( blob.path( cwd, sources[i].repo, sources[i].dir ) );\r\n        spl.wsSet ( input, `spl/blob.${spl.URI ( sources[i].repo, sources[i].dir.replace(\"../\",\"\") )}`, contents );\r\n        if( sources[i].reference ) \r\n            for(var j=0; j<sources[i].reference.length; j++) \r\n                spl.wsSet( input, sources[i].reference[j], `spl/blob.${spl.URI ( sources[i].repo, sources[i].dir.replace(\"../\",\"\") )}` );\r\n        spl.history ( input, `contents ${spl.fURI ( sources[i].repo, sources[i].dir )}`);\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/blob/contents_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/blob/contents\" },\r\n            { \"content\": \"Gets the folder contents from the filesystem.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/blob/contents <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the file is in.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the file is in.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The file or folder path in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The file or folder path in uri format in one part.\" }\r\n]\r\n}\r\n",
    "/boot/modules/spl/blob/copy.js": "//  name        Copies one or more files or dirs\r\n//  URI         spl/blob/copy\r\n//  type        API Method\r\n//  description This method copies one or more files or dirs.\r\n//              This method executes asynchrounously.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst blob = require(\"./blob.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_blob_copy ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var sources = spl.action ( input );\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i].from = blob.setLocation(sources[i].from)\r\n        sources[i].to = blob.setLocation(sources[i].to)\r\n        const fromPath = `${spl.URI(sources[i].from.repo, sources[i].from.dir)}/${((sources[i].from.file===undefined)?\"\":sources[i].from.file)}`;\r\n        const toPath = `${spl.URI(sources[i].to.repo, sources[i].to.dir)}/${((sources[i].to.file===undefined)?\"\":sources[i].to.file)}`;\r\n        blob.copyFile ( input, spl, blob.path(cwd, fromPath), blob.path(cwd, toPath) );\r\n        spl.history ( input, `copy ${fromPath} to ${toPath}` );\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/blob/copy_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/blob/copy\" },\r\n            { \"content\": \"Copies a file or folder from source to destination. Source and destination are in URI format.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/blob/copy <options>}\" }\r\n    ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"from\", \"alias\": \"f\", \"description\": \"The repository the file is in.\" }, \r\n        { \"name\": \"to\", \"alias\": \"t\", \"description\": \"The repository the file is in.\" }                               \r\n    ]\r\n}\r\n",
    "/boot/modules/spl/blob/delete.js": "//  name        Delete File or Dir\r\n//  URI         spl/blob/delete\r\n//  type        API Method\r\n//  description This method deletes one or more files or dirs\r\n//              This method executes asynchrounously.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst blob = require(\"./blob.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_blob_delete ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var sources = spl.action ( input );\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i] = blob.setLocation(sources[i]);\r\n        if( sources[i].file === undefined ) blob.deleteFile ( blob.path( cwd, sources[i].repo, sources[i].dir ) );\r\n        else blob.deleteFile ( input, spl, blob.path( cwd, sources[i].repo, sources[i].dir, sources[i].file ) );\r\n        spl.history ( input, `delete ${spl.URI(sources[i].repo, sources[i].dir)}/${((sources[i].file===undefined)?\"\":sources[i].file)}` );\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/blob/delete_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/blob/delete\" },\r\n            { \"content\": \"Deletes a file or folder from the filesystem.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/blob/delete <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the file is in.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the file is in.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The file or folder path in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The file or folder path in uri format in one part.\" }\r\n]\r\n}\r\n",
    "/boot/modules/spl/blob/get.js": "//  name        Gets the contents of a file\r\n//  URI         spl/blob/get\r\n//  type        API Method\r\n//  description Gets the contenst of one or more files.\r\n//              Currently only implemented for urf8\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst blob = require(\"./blob.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_blob_get ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var sources = spl.action ( input );\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i] = blob.setLocation(sources[i]);\r\n        const output = blob.getFile( blob.path( cwd, sources[i].repo, sources[i].dir, sources[i].file ) );\r\n        \r\n        // Determine encoding - default to 'json' for backward compatibility\r\n        const encoding = sources[i].encoding || 'json';\r\n        \r\n        let parsedOutput;\r\n        if ( encoding === 'text' ) {\r\n            // Store as plain text\r\n            parsedOutput = { headers: {}, value: output };\r\n        } else {\r\n            // Default behavior - parse as JSON\r\n            parsedOutput = JSON.parse ( output );\r\n        }\r\n        \r\n        spl.wsSet ( input, `spl/blob.${spl.fURI ( sources[i].repo, sources[i].dir, sources[i].file ).replace(\"../\",\"\")}`, parsedOutput );\r\n        if( sources[i].copy )\r\n            for(var j=0; j<sources[i].copy.length; j++)\r\n                spl.wsSet( input, sources[i].copy[j], structuredClone(output) );\r\n        if( sources[i].reference )\r\n            for(var j=0; j<sources[i].reference.length; j++)\r\n                spl.wsSet( input, sources[i].reference[j], `spl/blob.${spl.fURI ( sources[i].repo, sources[i].dir, sources[i].file ).replace(\"../\",\"\")}` );\r\n        spl.history ( input, `get ${spl.fURI ( sources[i].repo, sources[i].dir, sources[i].file )}`);\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/blob/get_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/blob/get\" },\r\n            { \"content\": \"Reads a file from the filesystem.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/blob/get <options>}\" }\r\n]\r\n    },\r\n    \"value\":\r\n    [\r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" },\r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the file is in.\" },\r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the file is in.\" },\r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name.\" },\r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The file or folder path in 3 space delimited parts.\" },\r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The file or folder path in uri format in one part.\" },\r\n        { \"name\": \"encoding\", \"alias\": \"e\", \"type\": \"String\", \"description\": \"File format: 'json' to parse as JSON (default), 'text' to read as plain text.\" }\r\n]\r\n}\r\n",
    "/boot/modules/spl/blob/index.js": "//  name        The spl/blob API\r\n//  URI         spl/blob\r\n//  type        API Module\r\n//  description A standard filesystem API for dirs and binary and text files\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/blob/move.js": "//  name        Move one or more files or dirs\r\n//  URI         spl/blob/move\r\n//  type        API Method\r\n//  description This method moves one or more files or dirs.\r\n//              This method executes asynchrounously.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst blob = require(\"./blob.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_blob_move ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var sources = spl.action ( input );\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i].from = blob.setLocation(sources[i].from)\r\n        sources[i].to = blob.setLocation(sources[i].to)\r\n        const fromPath = `${spl.URI(sources[i].from.repo, sources[i].from.dir)}/${((sources[i].from.file===undefined)?\"\":sources[i].from.file)}`;\r\n        const toPath = `${spl.URI(sources[i].to.repo, sources[i].to.dir)}/${((sources[i].to.file===undefined)?\"\":sources[i].to.file)}`;\r\n        blob.moveFile ( input, spl, blob.path(cwd, fromPath ), blob.path(cwd, toPath ) );\r\n        spl.history ( input, ` async - move ${fromPath} to ${toPath}` );\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/blob/move_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/blob/move\" },\r\n            { \"content\": \"Moves a file or folder from source to destination. Source and destination are in URI format.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/blob/move <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"from\", \"alias\": \"f\", \"description\": \"The repository the file is in.\" }, \r\n        { \"name\": \"to\", \"alias\": \"t\", \"description\": \"The repository the file is in.\" }                               \r\n]\r\n}\r\n",
    "/boot/modules/spl/blob/put.js": "//  name        Put File \r\n//  URI         spl/blob/put\r\n//  type        API Method\r\n//  description Saves one or more blob files to the filesystem.\r\n//              This method executes asynchronously.\r\n//              Currenlty only implemented for utf8.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst blob = require(\"./blob.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_blob_put ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var sources = spl.action ( input );\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i] = blob.setLocation(sources[i]);\r\n        if( sources[i].file === undefined ) blob.addDir ( input, spl, blob.path( cwd, sources[i].repo, sources[i].dir ) );\r\n        else {\r\n            if ( sources[i].contents ) \r\n                spl.wsSet( input, `spl/blob.${sources[i].repo}/${sources[i].dir}/${sources[i].file.replaceAll ( \".\", \"_\" )}`, { headers: {}, value: sources[i].contents } );\r\n            var contents = spl.wsGet( input, `spl/blob.${sources[i].repo}/${sources[i].dir}/${sources[i].file.replaceAll ( \".\", \"_\" )}` ).value;\r\n            if ( Array.isArray ( contents ) ) contents = contents.join ( \" \" );\r\n            blob.putFile ( input, spl, blob.path( cwd, sources[i].repo, sources[i].dir, sources[i].file ), contents );\r\n            spl.history ( input, `async - put file ${sources[i].repo}/${sources[i].dir}/${sources[i].file}` );\r\n        }\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/blob/put_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/blob/put\" },\r\n            { \"content\": \"Puts a file from the filesystem.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/blob/put <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the file is in.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the file is in.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The file or folder path in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The file or folder path in uri format in one part.\" },\r\n        { \"name\": \"contents\", \"alias\": \"c\", \"multiple\": true, \"description\": \"The contents of the file\" }\r\n]\r\n}\r\n",
    "/boot/modules/spl/blob_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/blob\" },\r\n            { \"content\": \"The API for common file system operations. Arguments set at the API level acts as defaults for the action arguments. All arguments used by the actions can be set. Furthermove, they remain for the lifetime of the pipeline.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/blob <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the file is in.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the file is in.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The file or folder path in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The file or folder path in uri format in one part.\" },\r\n        { \"name\": \"contents\", \"alias\": \"c\", \"description\": \"The contents of the file\" },\r\n        { \"name\": \"from\", \"alias\": \"f\", \"description\": \"The repository the file is in.\" }, \r\n        { \"name\": \"to\", \"alias\": \"t\", \"description\": \"The repository the file is in.\" }                                ]\r\n]\r\n}\r\n",
    "/boot/modules/spl/command/command.js": "//  name        Command Auxiliary Functions\r\n//  URI         spl/command/command\r\n//  type        Auxiliary Library\r\n//  description Contains the commandline parser.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst parser = require('command-line-args');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// activates the option types\r\nfunction activateTypes (options) {\r\n    for(var i=0; i<options.length; i++)\r\n        if (options[i].type) {\r\n            switch(options[i].type) {\r\n                case \"BigInt\": options[i].type = BigInt; break;\r\n                case \"Boolean\": options[i].type = Boolean; break;\r\n                case \"Number\": options[i].type = Number; break;\r\n                case \"String\": options[i].type = String; break;\r\n            }\r\n        }\r\n    return options;\r\n}\r\n\r\n// getCommandOptions \r\nexports.getHelpSection = function ( parseOptions, command ) {\r\n    var parts = command.split(\"/\");\r\n    if ( parts[0] === \"\" ) {\r\n        var packages = [];\r\n        for( key in parseOptions.packages ) packages.push ( { name: parseOptions.packages[key].header[0].header, summary: parseOptions.packages[key].header[1].content } );\r\n        var packageList =   {\r\n            header: 'Package List',\r\n            content: packages\r\n        }\r\n        return { \r\n            header: parseOptions.header, \r\n            options: { optionList: activateTypes ( structuredClone ( parseOptions.options ) ) },\r\n            subList: packageList\r\n        };\r\n    } else if ( parts.length == 1 ) {\r\n        var section = parseOptions.packages[parts[0]]\r\n        var apis = [];\r\n        for( key in section.apis ) apis.push ( { name: section.apis[key].header[0].header, summary: section.apis[key].header[1].content } );\r\n        var apiList =   {\r\n            header: 'API List',\r\n            content: apis\r\n        }\r\n        return {\r\n            header: section.header, \r\n            options: { optionList: activateTypes ( structuredClone ( section.options ) ) },\r\n            subList: apiList\r\n        };\r\n    } else if ( parts.length == 2 ) {\r\n        var section = parseOptions.packages[parts[0]].apis[parts[1]]\r\n        var methods = [];\r\n        for( key in section.methods ) methods.push ( { name: section.methods[key].header[0].header, summary: section.methods[key].header[1].content } );\r\n        var methodList =   {\r\n            header: 'Method List',\r\n            content: methods\r\n        }\r\n        return {\r\n            header: section.header, \r\n            options: { optionList: activateTypes ( structuredClone ( section.options ) ) },\r\n            subList: methodList\r\n        }\r\n    } else if ( parts.length == 3 ) {\r\n        var section = parseOptions.packages[parts[0]].apis[parts[1]].methods[parts[2]]\r\n        return {\r\n            header: section.header, \r\n            options: { optionList: activateTypes ( structuredClone ( section.options ) ) }\r\n        }\r\n    }\r\n}\r\n\r\n// getCommandOptions \r\nexports.getOptions = function ( parseOptions, command ) {\r\n    var parts = command.split(\"/\");\r\n    if ( parts[0] === \"\" ) return activateTypes ( structuredClone ( parseOptions.options ) );\r\n    else if ( parts.length == 1 )  return activateTypes ( structuredClone ( parseOptions.packages[parts[0]].options ) );\r\n    else if ( parts.length == 2 )  return activateTypes ( structuredClone ( parseOptions.packages[parts[0]].apis[parts[1]].options ) );\r\n    else if ( parts.length == 3 )  return activateTypes ( structuredClone ( parseOptions.packages[parts[0]].apis[parts[1]].methods[parts[2]].options ) );\r\n\r\n}\r\n\r\n// exists \r\nexports.exists = function ( parseOptions, command ) {\r\n    var parts = command.split(\"/\");\r\n    if ( parts[0] === \"\" ) return {};\r\n    else if ( parts.length == 1 )  return parseOptions.packages[parts[0]];\r\n    else if ( parts.length == 2 )  return parseOptions.packages[parts[0]].apis[parts[1]];\r\n    else if ( parts.length == 3 )  return parseOptions.packages[parts[0]].apis[parts[1]].methods[parts[2]];\r\n}\r\n\r\n// parse commandline section\r\nexports.parse = function (args, definitions) {\r\n    if(definitions === undefined) definitions = [{ name: 'command', defaultOption: true }];\r\n    return parser(definitions, { stopAtFirstUnknown: true, argv: args });\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n",
    "/boot/modules/spl/command/execute.js": "//  name        Execute Command\r\n//  URI         spl/command/execute API Method\r\n//  type        API Method\r\n//  description This is the entry point for commandline command execution.\r\n//              It sets the execution pipeline.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_command_execute (input) { \r\n\r\n    spl.wsSet(input, \"spl/execute.set-pipeline\", {\r\n        headers: {\r\n            spl: {\r\n                execute: {\r\n                    pipeline: [\r\n                        { action: \"spl/command/set\", \"spl/command/set\": spl.action ( input, \"set\" ) },\r\n                        { action: \"spl/command/write\", \"spl/command/write\": { destination: \"requests\" } }, \r\n                        { action: \"spl/command/load-parser-options\" },\r\n                        { action: \"spl/command/parse\" },\r\n                        { action: \"spl/command/write\", \"spl/command/write\": { destination: \"responses\" } },\r\n                    ]\r\n                }\r\n            }\r\n        }, \r\n        value: {}\r\n    });\r\n    spl.gotoExecute ( input, \"spl/execute/set-pipeline\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/command/execute_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/command/execute\" },\r\n            { \"content\": \"Entry point for command execution. DEPRECATED\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/command/execute <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/command/help.js": "//  name        Sets the command\r\n//  URI         spl/command/help\r\n//  type        API Method\r\n//  description Generates commandline help.\r\n//              Uses the parser.json file to store details.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\");\r\nconst command = require(\"./command\");\r\nconst help = require(\"command-line-usage\");\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_command_help ( input ) {\r\n    const helpRequests = spl.action( input );\r\n    const splCommand = spl.wsRef ( input, \"spl/command\" );\r\n    const parserOptionsURI = spl.fURI(\"spl/command\", splCommand.headers.spl.command.parser.file);\r\n    const parserOptions = spl.wsRef ( input, parserOptionsURI ).value;\r\n    var helpData = [];\r\n    helpData = helpData.concat ( parserOptions.top );\r\n    for ( var i=0; i < helpRequests.length; i++ ) {\r\n        var section = command.getHelpSection ( parserOptions, helpRequests[i] );\r\n        helpData = helpData.concat ( section.header );\r\n        if ( section.options ) helpData.push ( section.options );\r\n        if ( section.subList ) helpData.push ( section.subList );\r\n    }\r\n    helpData = helpData.concat ( parserOptions.bottom );\r\n    console.log(help(helpData))\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/command/help_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/command/help\" },\r\n            { \"content\": \"Print the help info. DEPRECATED\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/command/help <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/command/index.js": "//  name        Command API\r\n//  URI         spl/command\r\n//  type        API Module\r\n//  description This API implements the commandline parsing and command execution.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/command/load-parser-options.js": "//  name        Loads the parser options file\r\n//  URI         spl/command/load-parser-options\r\n//  type        API Method\r\n//  description Loads the parser options file\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_command_load_parser_options ( input ) {\r\n    const splCommand = spl.wsRef ( input, \"spl/command\" ).headers.spl.command.parser;\r\n    const parserUri = `spl/blob.${spl.fURI ( splCommand.repo, splCommand.dir, splCommand.file )}`;\r\n    const parserOptionsURI = `spl/command.${spl.fURI ( splCommand.file )}`;\r\n    const args = [ splCommand ];\r\n    splCommand.reference = [ parserOptionsURI ];\r\n\r\n    // reference must be entry within spl/command\r\n    if(!spl.wsExists ( input, parserUri, \"spl/blob/get\", args, true )) return;\r\n//    spl.wsSet ( input, parserOptionsURI,  spl.wsRef ( input, parserUri ) );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/command/load-parser-options_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/command/load-parser-options\" },\r\n            { \"content\": \"Parses the command. DEPRECATED\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/command/load-parser-options <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/command/parse.js": "//  name        Parse the commandline string\r\n//  URI         spl/command/parse\r\n//  type        API Method\r\n//  description Parses the commandline and sets the requested action.\r\n//              Uses the command-line-args module\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\");\r\nconst command = require(\"./command\");\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_command_parse (input) { \r\n\r\n  const parserOptionsURI = `spl/command.${spl.fURI ( spl.wsRef ( input, \"spl/command\" ).headers.spl.command.parser.file )}`;\r\n  const parseOptions = spl.wsRef(input, parserOptionsURI).value;\r\n  var splCmd, result, parseOnly = false, steps, registeredCommand, commandAction, pipeline = [], cmdArray = [], help = [], commandOptions = [];\r\n  input.headers.spl.command.help = help;\r\n  function parseCommand() {\r\n    if(result._unknown) {\r\n      result = command.parse(result._unknown)\r\n      commandAction += (commandAction === \"\") ? result.command : \"/\" + result.command;\r\n      if ( command.exists ( parseOptions, commandAction ) ) {\r\n        registeredCommand = commandAction;\r\n        splCmd.parsed[commandAction] = [];\r\n        if(result._unknown) {\r\n          commandOptions = command.getOptions ( parseOptions, commandAction );\r\n          result = command.parse ( result._unknown, commandOptions );\r\n          // check help flag - prepare to set help pipeline\r\n          if ( result.help ) help.push(registeredCommand)\r\n          splCmd.parsed[commandAction] = { headers: {}, value: result };\r\n        }\r\n      }\r\n    }\r\n    if( result._unknown && --counter > 0 ) parseCommand();   \r\n  }\r\n\r\n  // for each substring in commandstring array, set splCmd\r\n  // START PARSING SEQUENCE\r\n  // split the commandstring on the pipe symbol\r\n  cmdObject = spl.wsRef(input, \"spl/command\").value;\r\n  var cmdString = cmdObject.commandString.join(\" \").split(\"_!_\");\r\n  for(var i = 0; i<cmdString.length; i++) {\r\n    cmdArray.push( { commandString: cmdString[i].split(\" \") } );\r\n  }\r\n  spl.wsSet(input, \"spl/command.commands\", cmdArray);\r\n\r\n  for ( var i = 0; i<cmdArray.length; i++ ) {\r\n\r\n    commandAction = \"\";\r\n    registeredCommand = undefined;\r\n    splCmd = cmdArray[i];\r\n    splCmd.parsed = {};\r\n    var result = { _unknown: splCmd.commandString };\r\n    var counter = 3;\r\n\r\n    // parse global arguments - currently help, steps and test\r\n    commandOptions = command.getOptions ( parseOptions, commandAction );\r\n    result = command.parse ( result._unknown, commandOptions );\r\n    splCmd.parsed [ commandAction ] = { headers: {}, value: result };\r\n    if( !(result [ \"test\" ] === undefined ) ) parseOnly = true;\r\n    if( result [ \"steps\" ] > 0 ) steps = result [ \"steps\" ];\r\n    if ( result.help ) help.push ( commandAction );\r\n    if ( result.debug ) spl.setContext ( input, \"consoleMode\", \"debug\" );\r\n    else if ( result.verbose ) spl.setContext ( input, \"consoleMode\", \"verbose\" );\r\n\r\n    parseCommand();\r\n\r\n    // set pipeline to execute, MAKE SURE SPAWN IS SET (CREATE AGS FOR spl/execute/set-pipeline)\r\n    if ( registeredCommand != undefined ) {\r\n      const newRequest = { action: registeredCommand, status: \"pending\" };\r\n      newRequest[registeredCommand] = splCmd.parsed[registeredCommand].value;\r\n      if ( steps > 0 ) newRequest.TTL = steps;\r\n      pipeline.push(newRequest);\r\n    }\r\n  }\r\n\r\n  // switch to help pipeline if help flag was set, MAKE SURE SPAWN IS NOT SET (CREATE AGS FOR spl/execute/set-pipeline)\r\n  if( help.length > 0 ) {\r\n    pipeline = [ { action: \"spl/command/help\", \"spl/command/help\": help } ]\r\n  }\r\n\r\n  if ( !parseOnly ) {\r\n    if ( pipeline.length > 0 ) spl.wsSet(input, \"spl/execute.set-pipeline\", { headers: { spl: { execute: { pipeline: pipeline } } }, value: {} });\r\n//    spl.gotoExecute ( input, \"spl/execute/set-pipeline\" );\r\n    spl.gotoExecute ( input, \"spl/execute/spawn\" );\r\n  } else spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/command/parse_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/command/parse\" },\r\n            { \"content\": \"Parses the command. DEPRECATED\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/command/parse <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/command/set.js": "//  name        Sets the command\r\n//  URI         spl/command/set\r\n//  type        API Method\r\n//  description Loads the command template with client settings\r\n//              and sets the command.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_command_set ( input ) {\r\n\r\n    if(!spl.wsExists ( input, \"spl/command\", \"spl/data/read\", spl.action ( input, \"template\" ), true ) ) return;\r\n    var source = spl.action ( input );\r\n    var destination = spl.wsRef ( input, \"spl/command\" );\r\n    spl.rcSet( destination, \"headers.spl.command.repo\", source.template.repo );\r\n    spl.rcSet( destination, \"headers.spl.command.parser.repo\", source.template.repo );\r\n\r\n    // needs proper entry in spl/command\r\n    spl.wsSet( input, \"spl/command.commandString\", source.commandString );\r\n    spl.wsSet( input, \"spl/command.UUID\", source.UUID );\r\n\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/command/set_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/command/set\" },\r\n            { \"content\": \"Sets the command template. DEPRECATED\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/command/set <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/command/write.js": "//  name        Write Command Record\r\n//  URI         spl/command/write\r\n//  type        API Method\r\n//  description Writes a commasnd record to a dir - either requests or responses.\r\n//              It creates a timestamp filename.\r\n//              This method is used to log the initial and completed command.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_command_write ( input ) {\r\n    \r\n    const spl_command = spl.wsGet ( input,\"spl/command\" );\r\n    const repo = spl_command.headers.spl.command.repo;\r\n    const dir = spl.URI( \"commands\", spl.action ( input, \"destination\" ) );\r\n    input.headers.spl.data.write = [ { repo: repo, dir: dir } ];\r\n\r\n    for(key in spl_command.parsed) spl_command.value[key] = input.value[key];\r\n    spl.wsSet(input, `spl/data.${spl.URI(repo, dir)}`, spl_command)\r\n\r\n    spl.gotoExecute ( input, \"spl/data/write\", { repo: repo, dir: dir } );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/command/write_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/command/write\" },\r\n            { \"content\": \"Writes the execution record to app commands folder. DEPRECATED\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/command/write <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/command_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/command\" },\r\n            { \"content\": \"The initial API for command parsing and execution. DEPRECATED\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/command <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/console/error.js": "//  name        Prints an error message\r\n//  URI         spl/console/error\r\n//  type        API Method\r\n//  description Prints an error message to the Console\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_console_error (input) { \r\n    var message = spl.action ( input, \"message\" );\r\n    if(message.join) message = message.join(\" \");\r\n    console.error(message);\r\n    spl.completed(input);\r\n} \r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/console/error_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/console/error\" },\r\n            { \"content\": \"Writes a message to stderr of the console.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/console/error <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"message\", \"alias\": \"m\", \"type\": \"String\", \"multiple\": true, \"defaultOption\": true, \"description\": \"The message to display, as an array of strings\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/console/index.js": "//  name        Console API\r\n//  URI         spl/console\r\n//  type        API Module\r\n//  description This API implements the console API\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/console/log.js": "//  name        Log a message\r\n//  URI         spl/console/log\r\n//  type        API Method\r\n//  description Log a message to the Console\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_console_log (input) { \r\n    var message = spl.action ( input, \"message\" );\r\n    if ( message.join ) message = message.join ( \" \" );\r\n    console.log ( message );\r\n    spl.completed ( input );\r\n} \r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/console/log_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/console/log\" },\r\n            { \"content\": \"Writes a message to the console.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/console/log <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\" }, \r\n        { \"name\": \"message\", \"alias\": \"m\", \"type\": \"String\", \"multiple\": true, \"defaultOption\": true, \"description\": \"The message to display, as an array of strings\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/console/trace.js": "//  name        Prints a trace a message\r\n//  URI         spl/console/trace\r\n//  type        API Method\r\n//  description Print a trace message to the Console\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_console_trace (input) { \r\n    var message = spl.action ( input, \"message\" );\r\n    if ( message.join ) message = message.join ( \" \" );\r\n    console.trace ( message );\r\n    spl.completed ( input );\r\n} \r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/console/trace_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/console/trace\" },\r\n            { \"content\": \"Writes a trace message with stack to the console.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/console/trace <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"message\", \"alias\": \"m\", \"multiple\": true, \"defaultOption\": true }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/console/warn.js": "//  name        Prints a warning message\r\n//  URI         spl/console/warn\r\n//  type        API Method\r\n//  description Prints a warning message to the Console\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_console_warn (input) { \r\n    var message = spl.action ( input, \"message\" );\r\n    if ( message.join ) message = message.join ( \" \" );\r\n    console.warn ( message );\r\n    spl.completed ( input );\r\n} \r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/console/warn_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/console/warn\" },\r\n            { \"content\": \"Writes a warning message to the console.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/console/warn <opts>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"message\", \"alias\": \"m\", \"multiple\": true, \"defaultOption\": true }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/console_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/console\" },\r\n            { \"content\": \"Implements methods that write to the console.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/console <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/data/data.js": "//  name        Data Auxiliary Functions\r\n//  URI         spl/data/data\r\n//  type        Auxiliary Library\r\n//  description Contains common data functions used by the data API\r\n//              There is a mixture of synchronous and asynchronous methods.\r\n//              The initial implementation of the data layer is filesystem only.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// create a properly formatted file path\r\nexports.path = function ( ...args ){\r\n    return path.join(...args);\r\n}\r\n\r\n// reads a file record from the filesystem, if no name is supplied then the most recent record is read\r\nexports.readFileRecord = function (filePath, file) {\r\n    if (file === undefined) {\r\n        file = fs.readdirSync(filePath).filter(el => require('path').extname(el) === '.json').sort().reverse()[0];\r\n    }\r\n    var contents = fs.readFileSync(`${filePath}/${file}`, 'utf8');\r\n    return { file: file, contents: JSON.parse(contents) };\r\n}\r\n\r\n// create a properly formatted file path\r\nexports.setLocation = function ( location )\r\n{\r\n    if( Array.isArray(location) ) {\r\n        const newLocation = {};\r\n        newLocation.repo = location[0];\r\n        newLocation.dir = location[1];\r\n        newLocation.file = location[2];\r\n        location = newLocation; \r\n    } else if ( typeof location === \"string\" ) {\r\n        var uri = location.split(\"/\");\r\n        location = {};\r\n        location.file = (uri[uri.length-1].indexOf(\".\")>0) ? uri.pop() : undefined;\r\n        if ( (\"apps data packages\").includes(uri[0])) { location.repo = uri.slice(0,2).join(\"/\"); location.dir = uri.slice(2).join(\"/\"); }\r\n        else if ( uri[2] === \"data\" ) { location.repo = uri.slice(0,3).join(\"/\"); location.dir = uri.slice(3).join(\"/\"); }\r\n        else if ( uri[3] === \"data\" ) { location.repo = uri.slice(0,4).join(\"/\"); location.dir = uri.slice(4).join(\"/\"); }\r\n        else { location.repo = uri.join(\"/\"); location.dir = \"\"; }\r\n    } else if( Array.isArray(location.path) ) {\r\n        location.repo = location.path[0];\r\n        location.dir = location.path[1];\r\n        location.file = location.path[2]; \r\n    } else if ( typeof location.uri === \"string\" ) {\r\n        var uri = location.uri.split(\"/\");\r\n        location.file = (uri[uri.length-1].indexOf(\".\")>0) ? uri.pop() : undefined;\r\n        if ( (\"apps data packages\").includes(uri[0])) { location.repo = uri.slice(0,2).join(\"/\"); location.dir = uri.slice(2).join(\"/\"); }\r\n        else if ( uri[2] === \"data\" ) { location.repo = uri.slice(0,3).join(\"/\"); location.dir = uri.slice(3).join(\"/\"); }\r\n        else if ( uri[3] === \"data\" ) { location.repo = uri.slice(0,4).join(\"/\"); location.dir = uri.slice(4).join(\"/\"); }\r\n        else { location.repo = uri.join(\"/\"); location.dir = \"\"; }\r\n    }\r\n    return location;\r\n}\r\n\r\n// writes a file record to the filesystem, the name is a suffixed timestamp\r\nexports.writeFileRecord = function (filePath, contents) {\r\n    var suffix = 0;\r\n    var fileRecordPath;\r\n    filePath += `/${Date.now().toString()}`;\r\n\r\n    fs.writeFileSync(`${filePath}.tmp`, JSON.stringify(contents,null,2));\r\n    while(fs.existsSync(`${filePath}${suffix.toString()}.json`)) suffix += 1;\r\n    fileRecordPath = `${filePath}${suffix.toString()}.json`;\r\n    fs.renameSync(`${filePath}.tmp`,fileRecordPath);\r\n\r\n    return path.basename(fileRecordPath);\r\n}\r\n",
    "/boot/modules/spl/data/index.js": "//  name        Data API\r\n//  URI         spl/data\r\n//  type        API Module\r\n//  description This API implements the data record API.\r\n//              IIt deals with utf8 files only.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/data/queue.js": "//  name        Queue an Action\r\n//  URI         spl/data/queue\r\n//  type        API Method\r\n//  description Puts an Action request on the request queue\r\n//              set in the execution header.\r\n//              It writes it in Kafka record mode.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst data = require(\"./data.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_data_queue ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var session = spl.context ( input, \"session\" );\r\n    if( session !== \"boot\" && session !== \"system\" ) session = `sessions/${session}`;\r\n    const queueInput = JSON.stringify(spl.wsRef(input.value,`spl/data.${spl.URI(\"runtime\", session, \"requests/queue\")}`));\r\n    data.writeFileRecord ( data.path( cwd, \"runtime\", session, \"requests/queue\" ), queueInput );\r\n    spl.history ( input, `queue ${spl.URI(\"runtime\", session, \"requests/queue\")` );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/data/queue_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/data/queue\" },\r\n            { \"content\": \"Writes a record to a queue folder.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/data/queue <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/data/read.js": "//  name        Reads one or more Data Records\r\n//  URI         spl/data/read\r\n//  type        API Method\r\n//  description Reads one or more data records, by default the latest.\r\n//              This means the latest for a specific (primary) key.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst data = require(\"./data.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_data_read ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    var sources = spl.action ( input );\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i] = data.setLocation ( sources[i] );\r\n        var readPath = `${sources[i].repo}/${sources[i].dir}`;\r\n        const output = data.readFileRecord ( data.path ( cwd, readPath ), sources[i].file );\r\n        spl.rcSet ( output.contents, \"headers.spl.data\", { repo: sources[i].repo, dir: sources[i].dir, file: output.file } );\r\n        spl.history ( input, `read ${readPath}/${output.file}` );\r\n        if( !( sources[i].file === undefined ) ) readPath += `/${sources[i].file.replaceAll( \".\", \"_\" ) }`;\r\n        spl.wsSet ( input, `spl/data.${readPath}`, output.contents );\r\n        if( sources[i].copy ) \r\n            for( var j=0; j < sources[i].copy.length; j++ ) \r\n                spl.wsSet ( input, sources[i].copy[j], structuredClone( output.contents ) );\r\n        if( sources[i].reference ) \r\n            for( var j=0; j < sources[i].reference.length; j++ ) \r\n                spl.wsSet ( input, sources[i].reference[j], output.contents );\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/data/read_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/data/read\" },\r\n            { \"content\": \"Reads a record from a folder.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/data/read <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the record is in.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the record is in.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The record file name.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The record file or folder path in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The record file or folder path in uri format in one part.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/data/write.js": "//  name        Write one or more Data Records\r\n//  URI         spl/data/write\r\n//  type        API Method\r\n//  description Writes a new data record to a dir.\r\n//              It creates a timestamp filename.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst data = require(\"./data.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_data_write ( input ) {\r\n    const cwd = input.headers.spl.execute.cwd;\r\n    var sources = input.headers.spl.data.write;\r\n    if ( !Array.isArray(sources) ) sources = [ sources ];\r\n\r\n    for ( var i=0; i<sources.length; i++ ) {\r\n        sources[i] = data.setLocation ( sources[i] );\r\n        const dirPath = spl.URI(sources[i].repo, sources[i].dir);\r\n        if ( sources[i].contents ) spl.wsSet( input, `spl/data.${dirPath}`, sources[i].contents );\r\n        const fileName = data.writeFileRecord ( data.path ( cwd, dirPath ), spl.wsGet( input, `spl/data.${dirPath}` ) );\r\n        spl.rcSet( spl.wsRef ( input, `spl/data.${dirPath}` ), \"headers.spl.data.file\", fileName );\r\n        spl.history ( input, `write ${dirPath}/${fileName}`);\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/data/write_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/data/write\" },\r\n            { \"content\": \"Writes a record to a folder.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/data/write <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the record is in.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the record is in.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The record folder path in 2 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The record folder path in uri format in one part.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/data_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/data\" },\r\n            { \"content\": \"The API Kafka style data operations.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/data <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository the record is in.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory the record is in.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The record file name.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The record file or folder path in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The record file or folder path in uri format in one part.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/error/catch.js": "//  name        Catch error and process\r\n//  URI         spl/error/catch\r\n//  type        API Method\r\n//  description Implements error catching\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_error_catch ( input ) {\r\n    const message = spl.action ( input, \"message\" );\r\n    spl.setContext ( input, \"status\", \"red\" );\r\n    spl.history ( input, `ERROR - ${message}` );\r\n    spl.setContext ( input, \"action\", \"spl/execute/complete\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/error/catch_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/error/catch\" },\r\n            { \"content\": \"The action that registers caught errors.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/error/catch <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/error/index.js": "//  name        Error API\r\n//  URI         spl/error\r\n//  type        API Module\r\n//  description Manages the error handling.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/error_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/error\" },\r\n            { \"content\": \"Internal API for error handling.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/error <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute/complete.js": "//  name        Complete Execution\r\n//  URI         spl/execute/complete\r\n//  type        API Method\r\n//  description The last action of an action pipeline.\r\n//              Every continuous execution of a pipeline should finish with a complete action.\r\n//              This should happen after new execution segments have been spawned (if there are any)\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_execute_complete ( input ) {\r\n    spl.setContext ( input, \"finishTime\", Date.now() );\r\n    spl.setContext( input, \"duration\", spl.context ( input, \"finishTime\" ) - spl.context( input, \"startTime\" ) );\r\n    const status = spl.context ( input, \"status\" );\r\n    console.log( \"\" );\r\n    switch ( status ) {\r\n        case \"green\": console.log(`${spl.context ( input, \"history\" )[0][0]} completed succesfully ( ${spl.context ( input, \"duration\" )} ms ).`); break;\r\n        case \"orange\": console.log(`Command completed with warnings ( ${spl.context ( input, \"duration\" )} ms ).`); break;\r\n        case \"red\": console.log(`Command completed with errors ( ${spl.context ( input, \"duration\" )} ms ).`); break;\r\n    }\r\n    console.log( \"\" );\r\n//    console.dir ( input, { depth: 100 } );\r\n    if ( spl.context ( input, \"consoleMode\" ) === \"debug\" ) console.dir ( input, { depth: 100 } );\r\n    else if ( spl.context ( input, \"consoleMode\" ) === \"verbose\" ) console.log ( \"Verbose output mode not implemented yet.\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/complete_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute/complete\" },\r\n            { \"content\": \"The action completes every request execution.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/execute/complete <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute/execute.js": "//  name        Execute a pipeline segment\r\n//  URI         spl/execute/execute\r\n//  type        API Method\r\n//  description Manages the execution flow of a pipeline segment.\r\n//              It starts with an initialise action and finishes with a complete action.\r\n//              Output of bot actions is logged. \r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_execute_execute ( input ) {\r\n\r\n    function executeRequest(input) {\r\n        var session = spl.context ( input, \"session\" );\r\n        if ( session !== \"boot\" && session !== \"system\" ) session = `sessions/${session}`;\r\n        var execAction = ( spl.context( input, \"action\" ) === undefined ) ? \"spl/execute/initialise\" : spl.context ( input, \"action\" ) ;\r\n\r\n        spl.history ( input, \"\" );\r\n        //spl.moduleAction ( input, execAction );\r\n        try { spl.moduleAction ( input, execAction ); }\r\n        catch (e) { spl.throwError ( input, e.toString() ); }\r\n\r\n        // Update TTL -- NEEDS A SEPARATE ERROR SECTION IN THE WORKSPACE\r\n        spl.setContext ( input, \"TTL\", spl.context ( input, \"TTL\") - 1 );\r\n        if ( spl.context ( input, \"TTL\") < 1 && !( \"spl/error/catch spl/execute/complete\" ).includes ( execAction ) ) spl.throwError ( input, \"TTL has expired, execution aborted.\" );\r\n\r\n        if ( execAction === \"spl/execute/initialise\" || execAction === \"spl/execute/complete\" ) {\r\n\r\n            var dir = execAction.substring(execAction.lastIndexOf(\"/\")+1);\r\n            if ( spl.context ( input, \"runtimeMode\") != \"silent\" ) {\r\n                if ( dir === \"initialise\" ) {\r\n\r\n                    const filePath = spl.URI ( \"runtime\", session, \"requests/initialise\" );\r\n                    const writeRecord = {\r\n                        headers: { \r\n                            spl: { \r\n                                data: { write: [ { repo: spl.URI ( \"runtime\", session ), dir: \"requests/initialise\" } ], history: [] },\r\n                                execute: structuredClone ( spl.context ( input ) ),\r\n                                request: { action: \"spl/data/write\"}\r\n                            } \r\n                        },\r\n                        value: { \"spl/data\": { headers: {}, value: { [ filePath ]: structuredClone ( input ) } } }\r\n                    }\r\n                    spl.setContext ( writeRecord, \"action\", \"spl/execute/next\" );\r\n                    spl.moduleAction( writeRecord, \"spl/data/write\" );\r\n                    spl.setContext ( input, \"fileName\", spl.rcRef ( spl.wsRef ( writeRecord, `spl/data.${filePath}` ), \"headers.spl.data.file\" ) );\r\n                }\r\n                else {\r\n                    const putFile = {};\r\n                    putFile[ spl.fURI ( \"runtime\", session, \"requests/complete\", spl.context ( input, \"fileName\" ) ) ] = JSON.stringify ( input, null, 2 );\r\n                    const putRecord = {\r\n                        headers: { \r\n                            spl: { \r\n                                blob: { put: [ { repo: spl.URI ( \"runtime\", session ), dir: \"requests/complete\", file: spl.context ( input, \"fileName\" ) } ] },\r\n                                execute: structuredClone ( spl.context ( input ) ),\r\n                                request: { action: \"spl/blob/put\"}\r\n                            } \r\n                        },\r\n                        value: { \"spl/blob\": { headers: {}, value: putFile } }\r\n                    }\r\n                    spl.setContext ( putRecord, \"consoleProgress\", undefined );\r\n                    spl.setContext ( putRecord, \"action\", \"spl/execute/next\" );\r\n                    spl.moduleAction( putRecord, \"spl/blob/put\" );\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( execAction != \"spl/execute/complete\" ) setImmediate( () => executeRequest ( input ) );\r\n    }\r\n\r\n    setImmediate( () => executeRequest ( input ) );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/execute_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute/complete\" },\r\n            { \"content\": \"The action is the entry point for request execution and manages the flow.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/execute/execution <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute/index.js": "//  name        Execution API\r\n//  URI         spl/execute\r\n//  type        API Module\r\n//  description This module manages the execution flow.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/initialise.js": "//  name        Executes the Initialise Action\r\n//  URI         spl/execute/initialise\r\n//  type        API Method\r\n//  description Initialises the execution of a pipeline segemnt.\r\n//              The output of this action is logged.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_execute_initialise ( input ) {\r\n    if ( spl.request ( input, \"action\" ) == \"spl/execute/spawn\" ) {\r\n        spl.setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n    } else {\r\n        spl.setContext ( input, \"graph\", { UUID: spl.generateUUID(), ancestors: [], children: [] })\r\n        spl.setContext ( input, \"pipeline\", [ ]);\r\n        spl.setContext ( input, \"action\", \"spl/execute/next\" );\r\n    }\r\n    spl.setContext ( input, \"startTime\", Date.now() );\r\n    if( spl.context ( input, \"TTL\" ) === undefined ) spl.setContext ( input, \"TTL\", 100 );\r\n    spl.setContext ( input, \"status\", \"green\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/initialise_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute/initialise\" },\r\n            { \"content\": \"This is the first action .\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/execute/initialise <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute/next.js": "//  name        Executes the next action\r\n//  URI         spl/execution/next\r\n//  type        API Method\r\n//  description Executes the next action request.\r\n//              It also routes data and error tasks raised by the request action.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_execute_next ( input ) \r\n{\r\n    spl.moduleAction(input, spl.request ( input, \"action\" ) );\r\n    switch(spl.request ( input, \"status\" ) ) {\r\n        case \"data\": \r\n            spl.setContext( input, \"action\", spl.request ( input, \"data_next\" ) ); \r\n            spl.setContext( input, \"repeatRequest\", spl.request ( input, \"repeat\" ) ); \r\n        break;\r\n        case \"blob\": \r\n            spl.setContext( input, \"action\", spl.request ( input, \"blob_next\" ) ); \r\n            spl.setContext( input, \"repeatRequest\", spl.request ( input, \"repeat\" ) );\r\n        break;\r\n        case \"error\": spl.setContext( input, \"action\", \"spl/error/catch\" ); break;\r\n        case \"execute\": spl.setContext( input, \"action\", spl.request ( input, \"execute_next\" ) ); break;\r\n        case \"completed\": spl.setContext( input, \"action\", \"spl/execute/set-next\" ); break;\r\n        default: spl.setContext( input, \"action\", \"spl/execute/complete\" );\r\n    }\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/next_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute/next\" },\r\n            { \"content\": \"This action executes the current request.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/execute/next <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute/set-next.js": "//  name        Set Next Request\r\n//  URI         spl/execute/set-next\r\n//  type        API Method\r\n//  description Sets the next request action to execute from the execution pipeline.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\");\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_execute_set_next ( input ) {\r\n    if(spl.context ( input, \"repeatRequest\" ) ) {\r\n        spl.setContext ( input, \"repeatRequest\", false );\r\n        spl.setContext ( input, \"action\",\"spl/execute/next\" );\r\n    }\r\n    else if ( spl.context ( input, \"pipeline\" ).length > 0 ) {\r\n        spl.setRequest ( input, null, structuredClone ( spl.context ( input, \"pipeline\" ).shift() ) );\r\n        const requestAction = spl.request ( input, \"action\" );\r\n        const requestArgs = spl.request ( input, requestAction );\r\n        if ( requestArgs ) spl.rcSet( input.headers, requestAction.replaceAll(\"/\",\".\"), requestArgs );\r\n        if( spl.request ( input, \"TTL\" ) > 0 ) spl.setContext( input, \"TTL\", spl.request ( input, \"TTL\" ) );\r\n        spl.setContext ( input, \"action\", \"spl/execute/next\" );\r\n    } \r\n    else spl.setContext ( input, \"action\", \"spl/execute/complete\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/set-next_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute/set-next\" },\r\n            { \"content\": \"This action sets the new action to be executed, taken from the pipeline.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/execute/set-next <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute/set-pipeline.js": "//  name        Set Pipeline\r\n//  URI         spl/execute/set-pipeline\r\n//  type        API Method\r\n//  description Adds a new pipeline to the existing one.\r\n//              This offers a flexible mechanism to set the execution plan \r\n//              of an action at runtime. \r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = async function spl_execute_set_pipeline ( input )\r\n{\r\n    // spawn == false;\r\n    const newPipeline = structuredClone ( spl.rcRef ( spl.wsRef ( input, \"spl/execute.set-pipeline\" ), \"headers.spl.execute.pipeline\" ) );\r\n    spl.setContext ( input, \"pipeline\", newPipeline.concat ( spl.context ( input, \"pipeline\" ) ) );\r\n    spl.setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/set-pipeline_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute/set-pipeline\" },\r\n            { \"content\": \"This action adds a new pipeline to the front of the existing pipeline of the execution record.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/execute/set-pipeline <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute/spawn.js": "//  name        spawn\r\n//  URI         spl/execute/spawn\r\n//  type        API Method\r\n//  description Spawns a child request with a new pipeline.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = async function spl_execute_spawn ( input )\r\n{\r\n    const childUUID = spl.generateUUID();\r\n    const graph = spl.context ( input, \"graph\" );\r\n    graph.children.push ( childUUID );\r\n    spawnInput = { headers: { spl: { execute: {}, request: { action: \"spl/execute/spawn\" } } }, value: {} }\r\n    const execute = {\r\n        action: \"spl/execute/initialise\", \r\n        history: [], \r\n        consoleProgress: \"start\",\r\n        consoleMode: \"standard\", // silent, warning, verbose, debug \r\n        runtimeMode: spl.context ( input, \"runtimeMode\" ),\r\n        cwd: spl.context ( input, \"cwd\" ), \r\n        session: spl.context ( input, \"session\" ),  \r\n        modules: spl.context ( input, \"modules\" ),\r\n        pipeline:  structuredClone ( spl.context ( spl.wsRef ( input, \"spl/execute.set-pipeline\" ), \"pipeline\" ) ),\r\n        graph: { UUID: childUUID, ancestors: structuredClone( graph.ancestors ), children: [] }\r\n    }; \r\n    execute.graph.ancestors.unshift ( graph.UUID );\r\n    spl.setContext ( spawnInput, null, execute );\r\n    setImmediate ( () => spl.moduleAction ( spawnInput, \"spl/execute/execute\" ) );\r\n    spl.setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/execute/spawn_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute/spawn\" },\r\n            { \"content\": \"This creates a child request with a new execution record and spawns it.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/execute/spawn <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/execute_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/execute\" },\r\n            { \"content\": \"Internal API to manage the execution flow of requests.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/execute <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/git/git.js": "//  name        Git Simplified Functions\r\n//  URI         git/git\r\n//  type        Auxiliary Library\r\n//  description Simplified git functions with minimal overhead\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst { execSync } = require('child_process');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Simple git command execution\r\nexports.executeGit = function (input, spl, args, repoPath) {\r\n    const resolvedPath = repoPath || spl.action(input, 'path') || spl.context(input, 'cwd');\r\n    const gitCommand = `git ${args.join(' ')}`;\r\n    \r\n    spl.history(input, `executing: ${gitCommand} in ${resolvedPath}`);\r\n    \r\n    try {\r\n        const output = execSync(gitCommand, {\r\n            cwd: resolvedPath,\r\n            encoding: 'utf8'\r\n        });\r\n        \r\n        spl.history(input, `git command completed successfully`);\r\n        return output;\r\n    } catch (error) {\r\n        const errorMessage = error.stderr || error.message || 'Unknown git error';\r\n        spl.history(input, `ERROR - git command failed: ${gitCommand} - ${errorMessage}`);\r\n        spl.throwError(input, `Git command failed: ${errorMessage}`);\r\n    }\r\n};\r\n\r\n// Get repository path with simple fallback\r\nexports.getRepoPath = function (input, spl) {\r\n    return spl.action(input, 'path') || spl.context(input, 'cwd');\r\n};\r\n\r\n// Simple repository validation\r\nexports.validateRepository = function (input, spl, repoPath) {\r\n    if (!fs.existsSync(repoPath)) {\r\n        spl.throwError(input, `Path does not exist: ${repoPath}`);\r\n        return false;\r\n    }\r\n    \r\n    const gitDir = path.join(repoPath, '.git');\r\n    if (!fs.existsSync(gitDir)) {\r\n        spl.throwError(input, `Not a git repository: ${repoPath}`);\r\n        return false;\r\n    }\r\n    \r\n    return true;\r\n};\r\n///////////////////////////////////////////////////////////////////////////////",
    "/boot/modules/spl/git/index.js": "//  name        Git API (Simplified)\r\n//  URI         spl/git\r\n//  type        API Module\r\n//  description Simplified Git API that just validates the repository path\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst git = require(\"./git\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_git(input) {\r\n    const repoPath = git.getRepoPath(input, spl);\r\n    \r\n    // Just validate the repository exists\r\n    if (git.validateRepository(input, spl, repoPath)) {\r\n        spl.history(input, `Git API initialized with repository: ${repoPath}`);\r\n        console.log(`Git repository validated: ${repoPath}`);\r\n    }\r\n    \r\n    spl.completed(input);\r\n}\r\n///////////////////////////////////////////////////////////////////////////////",
    "/boot/modules/spl/git/status.js": "//  name        Git Status (Simplified)\r\n//  URI         spl/git/status\r\n//  type        API Method\r\n//  description Simplified git status that just executes the command and shows output\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst git = require(\"./git\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_git_status(input) {\r\n    const repoPath = git.getRepoPath(input, spl);\r\n    \r\n    // Validate repository exists\r\n    if (!git.validateRepository(input, spl, repoPath)) {\r\n        return;\r\n    }\r\n    \r\n    // Build git status command arguments\r\n    const args = ['status'];\r\n    \r\n    // Add optional flags\r\n    if (spl.action(input, 'porcelain')) {\r\n        args.push('--porcelain');\r\n    }\r\n    \r\n    if (spl.action(input, 'short')) {\r\n        args.push('--short');\r\n    }\r\n    \r\n    // Execute git status command\r\n    const output = git.executeGit(input, spl, args, repoPath);\r\n    \r\n    // Simple output to console\r\n    console.log('Git Status:');\r\n    console.log('===========');\r\n    console.log(output);\r\n    \r\n    spl.completed(input);\r\n}\r\n///////////////////////////////////////////////////////////////////////////////",
    "/boot/modules/spl/git/status_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/git/status\" },\r\n            { \"content\": \"Gets the current repository status showing staged, modified, and untracked files.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/git/status <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"porcelain\", \"alias\": \"p\", \"type\": \"Boolean\", \"description\": \"Give the output in an easy-to-parse format for scripts\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"short\", \"alias\": \"s\", \"type\": \"Boolean\", \"description\": \"Give the output in the short-format\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}",
    "/boot/modules/spl/git_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/git\" },\r\n            { \"content\": \"Git API for repository management. Sets repository context for subsequent git operations.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/git <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"description\": \"Repository path (defaults to current working directory)\" }, \r\n        { \"name\": \"create\", \"alias\": \"c\", \"type\": \"Boolean\", \"description\": \"Create directory if it doesn't exist\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}",
    "/boot/modules/spl/index.js": "//  name        The spl Package\r\n//  URI         spl\r\n//  type        Module Package\r\n//  description The spl package contains the minimal core functionality\r\n//              for a running SPlectrum install that can be extended\r\n//              with additional modules.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/create.js": "//  name        Create a Package\r\n//  URI         spl/package/create\r\n//  type        API Method\r\n//  description Creates a new package from an existing data or module install\r\n//              It creates a package of parts of an existing install.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst package = require(\"./package\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_package_create ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    const requestArgs = package.setLocation ( spl.action ( input ) );\r\n    const repo = requestArgs.repo;\r\n    const packageRef = `spl/package.${spl.fURI ( requestArgs.file )}`;\r\n    spl.wsSet ( input, packageRef, { headers: { spl: { package: { name: requestArgs.file } } }, value: {} } );\r\n    const packageContents = spl.wsRef ( input, packageRef ).value;\r\n    function iterateDir ( dirPath ) {\r\n        var contents = package.dirContents ( package.path ( cwd, repo, dirPath ) );\r\n        if ( contents.length === 0 ) packageContents[`${dirPath}/`] = {};\r\n        else {\r\n            for ( var i = 0; i < contents.length; i++ ) {\r\n                var currentPath = `${dirPath}/${contents[i]}`;\r\n                if ( package.isFile ( package.path ( cwd, repo, currentPath ) ) ) packageContents[currentPath] = package.getFile( input, spl, package.path ( cwd, repo, currentPath ) );\r\n                else iterateDir ( currentPath );\r\n            }   \r\n        }\r\n    }\r\n    iterateDir( requestArgs.dir ? `/${requestArgs.dir}` : \"\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/create_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/package/create\" },\r\n            { \"content\": \"Creates a package in the workspace under the supplied name.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/package/create <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository of the package source.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory of the package source.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name of the package source.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The path of the package source in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The path of the package source in uri format in one part.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/package/deploy.js": "//  name        Deploy a Package\r\n//  URI         spl/package/deploy\r\n//  type        API Method\r\n//  description Deploys a package to an existing install.\r\n//              It is used to deliver data and module packages.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\nconst package = require(\"./package.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_package_deploy ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    const requestArgs = package.setLocation ( spl.action ( input ) );\r\n    const repo = requestArgs.repo;\r\n    const dir = requestArgs.dir;\r\n    const packageRef = `spl/package.${spl.fURI ( requestArgs.file )}`;\r\n    const packageContents = spl.wsRef ( input, packageRef ).value;\r\n    for ( key in packageContents ) {\r\n        var dirName = key.substring ( 0, key.lastIndexOf( \"/\" ) );\r\n        var fileName = key.substring ( key.lastIndexOf ( \"/\" ) + 1 );\r\n        package.addDir ( input, spl, package.path ( cwd, repo, dir, dirName ) );\r\n        if ( fileName.length > 0 ) package.putFile ( input, spl, package.path ( cwd, repo, dir, key ), packageContents[key] );\r\n    }\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/deploy_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/package/deploy\" },\r\n            { \"content\": \"Deploys a package from the workspace to the filesystem.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/package/deploy <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository of the package destination.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory of the package destination.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name of the package destination.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The path of the package destination in 2 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The path of the package destination in uri format in one part.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/package/index.js": "//  name        Package API\r\n//  URI         spl/package\r\n//  type        API Module\r\n//  description This API manages data and module packages.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/load.js": "//  name        Load a Package\r\n//  URI         spl/package/load\r\n//  type        API Method\r\n//  description Loads a package from file.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst package = require(\"./package\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_package_load ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    const source = package.setLocation ( spl.action ( input ) );\r\n    const output = package.getFile ( input, spl, package.path ( cwd, source.repo, source.dir, source.file ) );\r\n    spl.wsSet ( input, `spl/package.${spl.fURI ( source.file )}`, JSON.parse( output ) );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/load_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/package/load\" },\r\n            { \"content\": \"Loads a package from the filesystem in the workspace.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/package/load <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository of the package source.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory of the package source.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name of the package source.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The path of the package source in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The path of the package source in uri format in one part.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/package/package.js": "//  name        package Auxiliary Functions\r\n//  URI         package/package\r\n//  type        Auxiliary Library\r\n//  description Contains the common functions for the package API.\r\n//              These are very similar to the filesystem data library.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// adds a full dir path \r\nexports.addDir = function ( input, spl, dirPath ) {\r\n    spl.history ( input, `addDir ${dirPath}` );\r\n    fs.mkdirSync(dirPath, { recursive: true });\r\n}\r\n\r\n// returns an array of files and dirs - synchronous\r\nexports.dirContents = function ( dirPath ) {\r\n    return fs.readdirSync(dirPath);    \r\n}\r\n\r\n// gets the contents of a file from the filesystem - synchronous\r\nexports.getFile = function ( input, spl, filePath ) {\r\n    spl.history ( input, `get ${filePath}` );\r\n    return fs.readFileSync( filePath, 'utf8' );\r\n}\r\n\r\n// Checks if the dir item is a file or dir - synchronous\r\nexports.isFile = function ( filePath ) { return fs.lstatSync ( filePath ).isFile(); }\r\n\r\n// create a properly formatted file path\r\nexports.path = function ( ...args ){\r\n    return path.join(...args);\r\n}\r\n\r\n// put file asynchronously, in the background - asynchronous\r\nexports.putFile = function ( input, spl, filePath, contents ) {\r\n    fs.writeFile ( filePath, contents, ( err ) => {\r\n        if ( err ) spl.history ( input, `ERROR - async - put file ${filePath} - ${err.toString()}` ); \r\n        else spl.history ( input, `async - COMPLETED put file ${filePath}` );\r\n     });\r\n}\r\n\r\n// removes a full dir path with file contents\r\nexports.removeDir = function ( input, spl, dirPath ) {\r\n    spl.history ( input, `removeDir ${dirPath}` );\r\n    fs.rmSync ( dirPath, { recursive: true, force: true } );\r\n}\r\n\r\n// create a properly formatted file path\r\nexports.setLocation = function ( location )\r\n{\r\n    if( Array.isArray(location) ) {\r\n        const newLocation = {};\r\n        newLocation.repo = location[0];\r\n        newLocation.dir = location[1];\r\n        newLocation.file = location[2];\r\n        location = newLocation; \r\n    } else if ( typeof location === \"string\" ) {\r\n        var uri = location.split(\"/\");\r\n        location = {};\r\n        location.file = (uri[uri.length-1].indexOf(\".\")>0) ? uri.pop() : undefined;\r\n        if ( (\"apps data packages\").includes(uri[0])) { location.repo = uri.slice(0,2).join(\"/\"); location.dir = uri.slice(2).join(\"/\"); }\r\n        else if ( uri[2] === \"data\" ) { location.repo = uri.slice(0,3).join(\"/\"); location.dir = uri.slice(3).join(\"/\"); }\r\n        else if ( uri[3] === \"data\" ) { location.repo = uri.slice(0,4).join(\"/\"); location.dir = uri.slice(4).join(\"/\"); }\r\n        else { location.repo = uri.join(\"/\"); location.dir = \"\"; }\r\n    } else if( Array.isArray(location.path) ) {\r\n        location.repo = location.path[0];\r\n        location.dir = location.path[1];\r\n        location.file = location.path[2]; \r\n    } else if ( typeof location.uri === \"string\" ) {\r\n        var uri = location.uri.split(\"/\");\r\n        location.file = (uri[uri.length-1].indexOf(\".\")>0) ? uri.pop() : undefined;\r\n        if ( (\"apps data packages\").includes(uri[0])) { location.repo = uri.slice(0,2).join(\"/\"); location.dir = uri.slice(2).join(\"/\"); }\r\n        else if ( uri[2] === \"data\" ) { location.repo = uri.slice(0,3).join(\"/\"); location.dir = uri.slice(3).join(\"/\"); }\r\n        else if ( uri[3] === \"data\" ) { location.repo = uri.slice(0,4).join(\"/\"); location.dir = uri.slice(4).join(\"/\"); }\r\n        else { location.repo = uri.join(\"/\"); location.dir = \"\"; }\r\n    }\r\n    return location;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/remove.js": "//  name        Remove a Package\r\n//  URI         spl/package/remove\r\n//  type        API Method\r\n//  description Removes a package from an install.\r\n//              A package in this context is assumend to be a hive,\r\n//              a top dir where everything underneath belongs to the package.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\nconst package = require(\"./package\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_package_remove ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    const requestArgs = package.setLocation ( spl.action ( input ) );\r\n    const repo = requestArgs.repo;\r\n    const dir = requestArgs.dir;\r\n    const basePath = package.path ( cwd, repo, dir );\r\n    const packageRef = `spl/package.${spl.fURI ( requestArgs.file )}`;\r\n    const dirs = spl.wsRef ( input, packageRef ).value;\r\n    for ( key in dirs ) package.removeDir( input, spl, package.path ( basePath, key ) );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/remove_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/package/remove\" },\r\n            { \"content\": \"Removes a package from the filesystem.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/package/remove <options>}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository of the package.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory of the package.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name of the package.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The path of the package in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The path of the package in uri format in one part.\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/package/save.js": "//  name        Save a Package\r\n//  URI         spl/package/save\r\n//  type        API Method\r\n//  description Saves a package to file.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl\")\r\nconst package = require(\"./package.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_package_save ( input ) {\r\n    const cwd = spl.context ( input, \"cwd\" );\r\n    const requestArgs = package.setLocation ( spl.action ( input ) );\r\n    const repo = requestArgs.repo;\r\n    const dir = requestArgs.dir;\r\n    const dirPath = package.path ( cwd, repo, dir );\r\n    const packageRef = `spl/package.${spl.fURI ( requestArgs.file )}`;\r\n    package.addDir ( input, spl, dirPath );\r\n    package.putFile ( input, spl, package.path ( dirPath, requestArgs.file ), JSON.stringify( spl.wsRef ( input, packageRef ), null, 2 ) );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/package/save_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/package/save\" },\r\n            { \"content\": \"Saves a package from the workspace to the filesystem.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/package/save <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository of the package destination.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory of the package destination.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name of the package destination.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The path of the package destination in 2 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The path of the package destination in uri format in one part.\" }\r\n]\r\n}\r\n",
    "/boot/modules/spl/package_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/package\" },\r\n            { \"content\": \"Standalone API to manage creation and deployment of data and functional packages.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/package <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"repo\", \"alias\": \"r\", \"description\": \"The repository of the package source.\" }, \r\n        { \"name\": \"dir\", \"alias\": \"d\", \"description\": \"The directory of the package source.\" }, \r\n        { \"name\": \"file\", \"alias\": \"f\", \"description\": \"The file name of the package source.\" }, \r\n        { \"name\": \"path\", \"alias\": \"p\", \"multiple\": true, \"description\": \"The path of the package source in 3 space delimited parts.\" }, \r\n        { \"name\": \"uri\", \"alias\": \"u\", \"description\": \"The path of the package source in uri format in one part.\" }\r\n]\r\n}\r\n",
    "/boot/modules/spl/record/index.js": "//  name        The spl/record API\r\n//  URI         spl/record\r\n//  type        API Module\r\n//  description The record API data records with AVRO schemas\r\n//              It is the generic handler of data records.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/record_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/data\" },\r\n            { \"content\": \"The API to manage Kafka records with AVRO schemas.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/record <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/spl.js": "//  name        SPL Package Useful Functions\r\n//  URI         spl/spl\r\n//  type        Auxiliary Library\r\n//  description Library of auxiliary methods at package level\r\n//              It contains methods to invoke actions, set properties and\r\n//              interacts with the workspace.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst { randomUUID } = require('crypto');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Gets a configuration value associated with the action currently being executed\r\nfunction spl_action ( input, key )\r\n{\r\n    // get the current action\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_config ( input, action, key );\r\n}\r\nexports.action = spl_action;\r\n\r\n// Gets a configuration value for the specified action\r\nfunction spl_config ( input, action, key )\r\n{\r\n    // split the current action ( request or execute )\r\n    var parts = parts = action.split ( \"/\" ), result, entry;\r\n    const apiRef = `${parts[0]}.${parts[1]}`;\r\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\r\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\r\n    const methodRefUri = action;\r\n\r\n    // first: check execution header for method config\r\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\r\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // second: check workspace method entry header for method config\r\n    entry = spl_wsRef ( input, methodRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // third: check workspace API entry header  for method config\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // no API default for full method property set\r\n    if ( key === undefined ) return result; // no default\r\n\r\n    // fourth: check execution header for API config (default)\r\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n    \r\n    // fifth: check workspace API entry header for API config (default)\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, apiRef );\r\n        if ( !( result === undefined ) ) result = result[key];\r\n    }\r\n    return result;\r\n}\r\nexports.config = spl_config;\r\n\r\n// get execution context properties\r\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\r\nexports.context = spl_context;\r\n\r\n// get request properties only ( spl/execute/request )\r\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\r\nexports.request = spl_request;\r\n\r\n// set current action specific properties \r\nfunction spl_setAction ( input, key, value ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_setConfig ( input, action, key, value );\r\n}\r\nexports.setAction = spl_setAction;\r\n\r\n// set method / api specific properties \r\nfunction spl_setConfig ( input, action, key, value ) {\r\n    action = action.replaceAll ( \"/\", \".\" );\r\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\r\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\r\n}\r\nexports.setConfig = spl_setConfig;\r\n\r\n// set execution context properties\r\nfunction spl_setContext ( input, key, value ) { \r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.execute\", value ); \r\n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \r\n}\r\nexports.setContext = spl_setContext;\r\n\r\n// set request properties only ( spl/execute/request )\r\nfunction spl_setRequest ( input, key, value ) {\r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.request\", value );\r\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\r\n}\r\nexports.setRequest = spl_setRequest;\r\n\r\n// Complete request\r\nexports.completed = function ( input ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) {\r\n        action = spl_request ( input, \"action\" );\r\n        spl_setRequest ( input, \"status\", \"completed\" );\r\n    } else {\r\n        action = spl_context ( input, \"action\" );\r\n        spl_setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n    }\r\n    spl_rcDelete ( input.headers, action.replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\r\nexports.fURI = function ( ... args ) { \r\n    args[args.length-1] = args[args.length-1].replaceAll ( \".\", \"_\" );\r\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \"\") result.push(args[i]);;\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// random UUID generation\r\nfunction generateUUID() { return randomUUID(); }\r\nexports.generateUUID = generateUUID;\r\n\r\n// wsAction sets an action for the execution context\r\nexports.gotoExecute = function ( input, action, args )\r\n{\r\n    var parts = action.split ( \"/\" );\r\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n    spl_setRequest ( input, `${parts[1]}_next`, action );\r\n    spl_setRequest ( input, \"status\", parts[1] );\r\n    spl_setRequest ( input, \"repeat\", false );\r\n    spl_request ( input, \"action\" ); //.split ( \"/\" );\r\n    spl_rcDelete ( input.headers, spl_request ( input, \"action\" ).replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// add to execution history\r\nexports.history = function ( input, activity )\r\n{\r\n    const action = spl_request ( input, \"action\" ); \r\n    var message = [ action, spl_context ( input, \"action\" ), activity ];\r\n    var history = spl_context ( input, \"history\" );\r\n    if ( history === undefined ) history = spl_setContext ( input, \"history\", [] );\r\n    history.push ( message );\r\n    var consoleProgress = spl_context ( input, \"consoleProgress\" );\r\n    if ( consoleProgress && consoleProgress != action )\r\n    {\r\n        consoleProgress = action;\r\n        console.log ( ` > ${consoleProgress}` );\r\n        spl_setContext ( input, \"consoleProgress\", consoleProgress );\r\n    }\r\n    if ( activity.substring ( 0, 5 ) == \"ERROR\" ) console.error ( message.join ( \" - \" ) );\r\n    else if ( spl_context ( input, \"consoleMode\" ) != \"silent\" && activity.substring ( 0, 7 ) == \"WARNING\" ) console.error ( message.join ( \" - \" ) );\r\n}\r\n\r\n// easy functions to invoke actions\r\nexports.moduleAction = function (input, module)\r\n{\r\n    var moduleRoot = spl_context ( input, \"modules\" );\r\n    if ( moduleRoot === undefined ) moduleRoot = \"modules\";\r\n    var moduleOverlay = spl_context ( input, \"moduleOverlay\" );\r\n    if ( moduleOverlay )\r\n        for ( var i = 0; i < moduleOverlay.length; i++ )\r\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\r\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\r\n    return require ( `${ spl_context ( input, \"cwd\" )}/${moduleRoot}/${module}`).default ( input );\r\n}\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcDelete (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length - 1; i++)\r\n    {\r\n        if(reference[keys[i]]==undefined) return;\r\n        reference = reference[keys[i]];\r\n    }\r\n    delete reference[keys[i]];\r\n}\r\nexports.rcDelete = spl_rcDelete;\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\r\nexports.rcGet = spl_rcGet;\r\n\r\n// gets a reference to a keyvalue in input\r\nfunction spl_rcRef (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\r\n    return reference;\r\n}\r\nexports.rcRef = spl_rcRef;\r\n\r\n// Sets a value of a keyvalue in input\r\nfunction spl_rcSet (reference, key, value)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \r\n    reference[keys[i]] = value;\r\n    return reference[keys[i]]\r\n}\r\nexports.rcSet = spl_rcSet;\r\n\r\n// Complete request\r\nexports.throwError = function ( input, message )\r\n{\r\n    spl_setContext ( input, \"action\", \"spl/error/catch\" );\r\n    spl_setConfig ( input, \"spl/error/catch\", \"message\", message );\r\n}\r\n\r\n// construct a forward slash path for platform internal use\r\nexports.URI = function ( ...args ) { \r\n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \"\" ) result.push ( args[i] );\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// wsExists checks the presence of a property and loads it when not\r\nexports.wsExists = function ( input, key, action, args, repeat ) {\r\n    const parts = action.split ( \"/\" );\r\n    if( spl_wsRef ( input, key ) === undefined ) {\r\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n        else spl_rcSet ( input.headers, parts.join ( \".\" ), [args] );\r\n        spl_setRequest ( input, `${parts[1]}_next`, action );\r\n        spl_setRequest ( input, \"status\", parts[1] );\r\n        spl_setRequest ( input, \"repeat\", repeat );\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// wsGet returns a deep clone of a keyvalue in input.value.\r\nexports.wsGet = function ( input, key ) { \r\n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) ) ); \r\n}\r\n\r\n// wsRef returns a reference to a keyvalue in input.value.\r\nfunction spl_wsRef (input, key) \r\n{ \r\n    const parts = key.split ( \".\" );\r\n    var value = spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) );\r\n    if ( typeof value == \"string\" && !( \"spl/blob spl/package\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\r\n    return value;\r\n}\r\nexports.wsRef = spl_wsRef;\r\n\r\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\r\nexports.wsSet = function (input, key, value)\r\n{ \r\n    const expandedKey = key.replaceAll ( \".\", \".value.\" );\r\n    const current = spl_rcRef ( input.value, expandedKey );\r\n    if( !( current === undefined ) ) {\r\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\r\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\r\n        archive.push(current);\r\n    }\r\n    spl_rcSet ( input.value, expandedKey, value );\r\n}\r\n",
    "/boot/modules/spl/void/index.js": "//  name        Void API\r\n//  URI         spl/void\r\n//  type        API Module\r\n//  description This API contains methods with no input from or output into\r\n//              the data that is passed through.\r\n//              The can have side effects however.\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/void/noop.js": "//  name        No Operation\r\n//  URI         spl/void/noop\r\n//  type        API Method\r\n//  description This command does not execute any action.\r\n//              It is included to facilitate testing.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_void_noop (input) { \r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/boot/modules/spl/void/noop_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/void/noop\" },\r\n            { \"content\": \"The null operation.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> spl/void/noop <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl/void_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl/void\" },\r\n            { \"content\": \"The API miscellaneous actions that operate on no specific data structure.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> spl/void <apiOpts> <method>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/modules/spl.js": "//  name        SPL Package Useful Functions\r\n//  URI         spl/spl\r\n//  type        Auxiliary Library\r\n//  description Library of auxiliary methods at package level\r\n//              It contains methods to invoke actions, set properties and\r\n//              interacts with the workspace.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst { randomUUID } = require('crypto');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Gets a configuration value associated with the action currently being executed\r\nfunction spl_action ( input, key )\r\n{\r\n    // get the current action\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_config ( input, action, key );\r\n}\r\nexports.action = spl_action;\r\n\r\n// Gets a configuration value for the specified action\r\nfunction spl_config ( input, action, key )\r\n{\r\n    // split the current action ( request or execute )\r\n    var parts = parts = action.split ( \"/\" ), result, entry;\r\n    const apiRef = `${parts[0]}.${parts[1]}`;\r\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\r\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\r\n    const methodRefUri = action;\r\n\r\n    // first: check execution header for method config\r\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\r\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // second: check workspace method entry header for method config\r\n    entry = spl_wsRef ( input, methodRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // third: check workspace API entry header  for method config\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // no API default for full method property set\r\n    if ( key === undefined ) return result; // no default\r\n\r\n    // fourth: check execution header for API config (default)\r\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n    \r\n    // fifth: check workspace API entry header for API config (default)\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, apiRef );\r\n        if ( !( result === undefined ) ) result = result[key];\r\n    }\r\n    return result;\r\n}\r\nexports.config = spl_config;\r\n\r\n// get execution context properties\r\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\r\nexports.context = spl_context;\r\n\r\n// get request properties only ( spl/execute/request )\r\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\r\nexports.request = spl_request;\r\n\r\n// set current action specific properties \r\nfunction spl_setAction ( input, key, value ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_setConfig ( input, action, key, value );\r\n}\r\nexports.setAction = spl_setAction;\r\n\r\n// set method / api specific properties \r\nfunction spl_setConfig ( input, action, key, value ) {\r\n    action = action.replaceAll ( \"/\", \".\" );\r\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\r\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\r\n}\r\nexports.setConfig = spl_setConfig;\r\n\r\n// set execution context properties\r\nfunction spl_setContext ( input, key, value ) { \r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.execute\", value ); \r\n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \r\n}\r\nexports.setContext = spl_setContext;\r\n\r\n// set request properties only ( spl/execute/request )\r\nfunction spl_setRequest ( input, key, value ) {\r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.request\", value );\r\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\r\n}\r\nexports.setRequest = spl_setRequest;\r\n\r\n// Complete request\r\nexports.completed = function ( input ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) {\r\n        action = spl_request ( input, \"action\" );\r\n        spl_setRequest ( input, \"status\", \"completed\" );\r\n    } else {\r\n        action = spl_context ( input, \"action\" );\r\n        spl_setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n    }\r\n    spl_rcDelete ( input.headers, action.replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\r\nexports.fURI = function ( ... args ) { \r\n    args[args.length-1] = args[args.length-1].replaceAll ( \".\", \"_\" );\r\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \"\") result.push(args[i]);;\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// random UUID generation\r\nfunction generateUUID() { return randomUUID(); }\r\nexports.generateUUID = generateUUID;\r\n\r\n// wsAction sets an action for the execution context\r\nexports.gotoExecute = function ( input, action, args )\r\n{\r\n    var parts = action.split ( \"/\" );\r\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n    spl_setRequest ( input, `${parts[1]}_next`, action );\r\n    spl_setRequest ( input, \"status\", parts[1] );\r\n    spl_setRequest ( input, \"repeat\", false );\r\n    spl_request ( input, \"action\" ); //.split ( \"/\" );\r\n    spl_rcDelete ( input.headers, spl_request ( input, \"action\" ).replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// add to execution history\r\nexports.history = function ( input, activity )\r\n{\r\n    const action = spl_request ( input, \"action\" ); \r\n    var message = [ action, spl_context ( input, \"action\" ), activity ];\r\n    var history = spl_context ( input, \"history\" );\r\n    if ( history === undefined ) history = spl_setContext ( input, \"history\", [] );\r\n    history.push ( message );\r\n    var consoleProgress = spl_context ( input, \"consoleProgress\" );\r\n    if ( consoleProgress && consoleProgress != action )\r\n    {\r\n        consoleProgress = action;\r\n        console.log ( ` > ${consoleProgress}` );\r\n        spl_setContext ( input, \"consoleProgress\", consoleProgress );\r\n    }\r\n    if ( activity.substring ( 0, 5 ) == \"ERROR\" ) console.error ( message.join ( \" - \" ) );\r\n    else if ( spl_context ( input, \"consoleMode\" ) != \"silent\" && activity.substring ( 0, 7 ) == \"WARNING\" ) console.error ( message.join ( \" - \" ) );\r\n}\r\n\r\n// easy functions to invoke actions\r\nexports.moduleAction = function (input, module)\r\n{\r\n    var moduleRoot = spl_context ( input, \"modules\" );\r\n    if ( moduleRoot === undefined ) moduleRoot = \"modules\";\r\n    var moduleOverlay = spl_context ( input, \"moduleOverlay\" );\r\n    if ( moduleOverlay )\r\n        for ( var i = 0; i < moduleOverlay.length; i++ )\r\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\r\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\r\n    return require ( `${ spl_context ( input, \"cwd\" )}/${moduleRoot}/${module}`).default ( input );\r\n}\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcDelete (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length - 1; i++)\r\n    {\r\n        if(reference[keys[i]]==undefined) return;\r\n        reference = reference[keys[i]];\r\n    }\r\n    delete reference[keys[i]];\r\n}\r\nexports.rcDelete = spl_rcDelete;\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\r\nexports.rcGet = spl_rcGet;\r\n\r\n// gets a reference to a keyvalue in input\r\nfunction spl_rcRef (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\r\n    return reference;\r\n}\r\nexports.rcRef = spl_rcRef;\r\n\r\n// Sets a value of a keyvalue in input\r\nfunction spl_rcSet (reference, key, value)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \r\n    reference[keys[i]] = value;\r\n    return reference[keys[i]]\r\n}\r\nexports.rcSet = spl_rcSet;\r\n\r\n// Complete request\r\nexports.throwError = function ( input, message )\r\n{\r\n    spl_setContext ( input, \"action\", \"spl/error/catch\" );\r\n    spl_setConfig ( input, \"spl/error/catch\", \"message\", message );\r\n}\r\n\r\n// construct a forward slash path for platform internal use\r\nexports.URI = function ( ...args ) { \r\n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \"\" ) result.push ( args[i] );\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// wsExists checks the presence of a property and loads it when not\r\nexports.wsExists = function ( input, key, action, args, repeat ) {\r\n    const parts = action.split ( \"/\" );\r\n    if( spl_wsRef ( input, key ) === undefined ) {\r\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n        else spl_rcSet ( input.headers, parts.join ( \".\" ), [args] );\r\n        spl_setRequest ( input, `${parts[1]}_next`, action );\r\n        spl_setRequest ( input, \"status\", parts[1] );\r\n        spl_setRequest ( input, \"repeat\", repeat );\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// wsGet returns a deep clone of a keyvalue in input.value.\r\nexports.wsGet = function ( input, key ) { \r\n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) ) ); \r\n}\r\n\r\n// wsRef returns a reference to a keyvalue in input.value.\r\nfunction spl_wsRef (input, key) \r\n{ \r\n    const parts = key.split ( \".\" );\r\n    var value = spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) );\r\n    if ( typeof value == \"string\" && !( \"spl/blob spl/package\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\r\n    return value;\r\n}\r\nexports.wsRef = spl_wsRef;\r\n\r\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\r\nexports.wsSet = function (input, key, value)\r\n{ \r\n    const expandedKey = key.replaceAll ( \".\", \".value.\" );\r\n    const current = spl_rcRef ( input.value, expandedKey );\r\n    if( !( current === undefined ) ) {\r\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\r\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\r\n        archive.push(current);\r\n    }\r\n    spl_rcSet ( input.value, expandedKey, value );\r\n}\r\n",
    "/boot/modules/spl_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"spl Package\" },\r\n            { \"content\": \"Implements the core functionality of the SPlectrum platform.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> <package> <options> <api>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/boot/spl": "node spl.js $@\r\n",
    "/boot/spl.cmd": "node spl.js %*\r\n",
    "/boot/spl.js": "const spl = require(\"./modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst appRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = {   action: \"spl/execute/initialise\", consoleProgress: \"start\",  consoleMode: \"standard\", // silent, standard, warning, verbose, debug \r\n                    runtimeMode: \"silent\", cwd: splRoot, session: session, modules: `${appRoot}/modules`, TTL: 100 };\r\nconst action = \"spl/app/process\";\r\nconst batch = commandString;\r\n/*`spl/console/log hello world _!_ spl/console/error hello world 2\r\n -h    usr/noop \r\n -s 10  spl/app/exec -f simple-batch\r\nspl/app -h run -f testscript.js\r\nspl -h app/reset`;*/\r\nconst config = { appRoot: appRoot, batch: batch };\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, action, null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n"
  }
}