{
  "headers": {
    "spl": {
      "package": {
        "name": "apps_test-suite_test.json"
      }
    }
  },
  "value": {
    "/test-suite/actions/": {},
    "/test-suite/batches/blob-tests.txt": "spl/blob/get -r apps/test-suite -d data -f test.txt -e text\r\nspl/blob/put -r apps/test-suite -d data -f test1.txt -c This is test content for file 1\r\nspl/blob/copy -f apps/test-suite/data/test1.txt -t apps/test-suite/data/test1-copy.txt\r\nspl/blob/contents -r apps/test-suite -d data\r\nspl/blob/get -r apps/test-suite -d data -f test1.txt -e text\r\nspl/blob/move -f apps/test-suite/data/test1-copy.txt -t apps/test-suite/data/test1-moved.txt\r\nspl/blob/contents -r apps/test-suite -d data\r\nspl/blob/delete -r apps/test-suite -d data -f test1-moved.txt\r\nspl/blob/contents -r apps/test-suite -d data\r\nspl/blob/delete -r apps/test-suite -d data -f test1.txt\r\nspl/blob/contents -r apps/test-suite -d data\r\nspl/console/log Blob module tests completed\r\n",
    "/test-suite/batches/console-tests.txt": "spl/console/log Testing console log functionality\r\nspl/console/log This is a standard log message @@ spl/console/log Testing with special characters: !@#$%^&*()\r\nspl/console/warn This is a warning message @@ spl/console/warn Testing warning with multiple words and numbers 123\r\nspl/console/error This is an error message @@ spl/console/error Testing error handling capabilities\r\nspl/console/trace This is a trace message @@ spl/console/trace Testing trace functionality for debugging",
    "/test-suite/batches/package-tests.txt": "spl/console/log Starting Package API tests\r\nspl/package/create -r apps -d test2 -f test2-package.json @@ spl/package/save -r apps/test-suite -d packages -f test2-package.json\r\nspl/package/create -r apps -d test2 -f test2-package2.json @@ spl/package/save -r apps/test-suite -d packages -f test2-package2.json\r\nspl/package/load -r apps/test-suite -d packages -f test2-package.json @@ spl/package/deploy -r apps/test-suite -d data/test2-deployed -f test2-package.json\r\nspl/console/log Package API tests completed",
    "/test-suite/commands/requests/": {},
    "/test-suite/commands/responses/": {},
    "/test-suite/data/test.txt": "this is a test file.",
    "/test-suite/data/test2-deployed/test2/actions/": {},
    "/test-suite/data/test2-deployed/test2/batches/test-commands.txt": "spl/console/log Testing file-based command execution\r\nspl/console/log This is line 2\r\nspl/console/warn This is a warning message\r\nspl/console/log Final line from file",
    "/test-suite/data/test2-deployed/test2/commands/requests/": {},
    "/test-suite/data/test2-deployed/test2/commands/responses/": {},
    "/test-suite/data/test2-deployed/test2/modules/arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"top\" : [\r\n            { \"header\": \"SPlectrum Test App\" },\r\n            { \"content\": \"A client used to test the current package functionaltiy.\" }\r\n        ],\r\n        \"header\": [\r\n            { \"content\": \"Overview 1.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <options> <package>}\" }\r\n        ],\r\n        \"bottom\": [ \r\n            { \"content\": \"Project home: {underline https://github.com/SPlectrum/spl}\" } ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"test\", \"alias\": \"t\", \"type\": \"Boolean\", \"description\": \"test - parse commands but do not execute.\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"steps\", \"alias\": \"s\", \"type\": \"Number\", \"description\": \"TTL of the command execution.\"},\r\n        { \"name\": \"verbose\", \"alias\": \"v\", \"type\": \"Boolean\", \"description\": \"Do verbose output on completion.\"},\r\n        { \"name\": \"debug\", \"alias\": \"d\", \"type\": \"Boolean\", \"description\": \"Do debug output on completion.\"}\r\n    ]\r\n}\r\n",
    "/test-suite/data/test2-deployed/test2/modules/spl.js": "//  name        SPL Package Useful Functions\r\n//  URI         spl/spl\r\n//  type        Auxiliary Library\r\n//  description Library of auxiliary methods at package level\r\n//              It contains methods to invoke actions, set properties and\r\n//              interacts with the workspace.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst { randomUUID } = require('crypto');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Gets a configuration value associated with the action currently being executed\r\nfunction spl_action ( input, key )\r\n{\r\n    // get the current action\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_config ( input, action, key );\r\n}\r\nexports.action = spl_action;\r\n\r\n// Gets a configuration value for the specified action\r\nfunction spl_config ( input, action, key )\r\n{\r\n    // split the current action ( request or execute )\r\n    var parts = parts = action.split ( \"/\" ), result, entry;\r\n    const apiRef = `${parts[0]}.${parts[1]}`;\r\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\r\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\r\n    const methodRefUri = action;\r\n\r\n    // first: check execution header for method config\r\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\r\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // second: check workspace method entry header for method config\r\n    entry = spl_wsRef ( input, methodRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // third: check workspace API entry header  for method config\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // no API default for full method property set\r\n    if ( key === undefined ) return result; // no default\r\n\r\n    // fourth: check execution header for API config (default)\r\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n    \r\n    // fifth: check workspace API entry header for API config (default)\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, apiRef );\r\n        if ( !( result === undefined ) ) result = result[key];\r\n    }\r\n    return result;\r\n}\r\nexports.config = spl_config;\r\n\r\n// get execution context properties\r\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\r\nexports.context = spl_context;\r\n\r\n// get request properties only ( spl/execute/request )\r\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\r\nexports.request = spl_request;\r\n\r\n// set current action specific properties \r\nfunction spl_setAction ( input, key, value ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_setConfig ( input, action, key, value );\r\n}\r\nexports.setAction = spl_setAction;\r\n\r\n// set method / api specific properties \r\nfunction spl_setConfig ( input, action, key, value ) {\r\n    action = action.replaceAll ( \"/\", \".\" );\r\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\r\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\r\n}\r\nexports.setConfig = spl_setConfig;\r\n\r\n// set execution context properties\r\nfunction spl_setContext ( input, key, value ) { \r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.execute\", value ); \r\n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \r\n}\r\nexports.setContext = spl_setContext;\r\n\r\n// set request properties only ( spl/execute/request )\r\nfunction spl_setRequest ( input, key, value ) {\r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.request\", value );\r\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\r\n}\r\nexports.setRequest = spl_setRequest;\r\n\r\n// Complete request\r\nexports.completed = function ( input ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) {\r\n        action = spl_request ( input, \"action\" );\r\n        spl_setRequest ( input, \"status\", \"completed\" );\r\n    } else {\r\n        action = spl_context ( input, \"action\" );\r\n        spl_setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n    }\r\n    spl_rcDelete ( input.headers, action.replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\r\nexports.fURI = function ( ... args ) { \r\n    args[args.length-1] = args[args.length-1].replaceAll ( \".\", \"_\" );\r\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \"\") result.push(args[i]);;\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// random UUID generation\r\nfunction generateUUID() { return randomUUID(); }\r\nexports.generateUUID = generateUUID;\r\n\r\n// wsAction sets an action for the execution context\r\nexports.gotoExecute = function ( input, action, args )\r\n{\r\n    var parts = action.split ( \"/\" );\r\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n    spl_setRequest ( input, `${parts[1]}_next`, action );\r\n    spl_setRequest ( input, \"status\", parts[1] );\r\n    spl_setRequest ( input, \"repeat\", false );\r\n    spl_request ( input, \"action\" ); //.split ( \"/\" );\r\n    spl_rcDelete ( input.headers, spl_request ( input, \"action\" ).replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// add to execution history\r\nexports.history = function ( input, activity )\r\n{\r\n    const action = spl_request ( input, \"action\" ); \r\n    var message = [ action, spl_context ( input, \"action\" ), activity ];\r\n    var history = spl_context ( input, \"history\" );\r\n    if ( history === undefined ) history = spl_setContext ( input, \"history\", [] );\r\n    history.push ( message );\r\n    var consoleProgress = spl_context ( input, \"consoleProgress\" );\r\n    if ( consoleProgress && consoleProgress != action )\r\n    {\r\n        consoleProgress = action;\r\n        console.log ( ` > ${consoleProgress}` );\r\n        spl_setContext ( input, \"consoleProgress\", consoleProgress );\r\n    }\r\n    if ( activity.substring ( 0, 5 ) == \"ERROR\" ) console.error ( message.join ( \" - \" ) );\r\n    else if ( spl_context ( input, \"consoleMode\" ) != \"silent\" && activity.substring ( 0, 7 ) == \"WARNING\" ) console.error ( message.join ( \" - \" ) );\r\n}\r\n\r\n// easy functions to invoke actions\r\nexports.moduleAction = function (input, module)\r\n{\r\n    var moduleRoot = spl_context ( input, \"modules\" );\r\n    if ( moduleRoot === undefined ) moduleRoot = \"modules\";\r\n    var moduleOverlay = spl_context ( input, \"moduleOverlay\" );\r\n    if ( moduleOverlay )\r\n        for ( var i = 0; i < moduleOverlay.length; i++ )\r\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\r\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\r\n    return require ( `${ spl_context ( input, \"cwd\" )}/${moduleRoot}/${module}`).default ( input );\r\n}\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcDelete (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length - 1; i++)\r\n    {\r\n        if(reference[keys[i]]==undefined) return;\r\n        reference = reference[keys[i]];\r\n    }\r\n    delete reference[keys[i]];\r\n}\r\nexports.rcDelete = spl_rcDelete;\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\r\nexports.rcGet = spl_rcGet;\r\n\r\n// gets a reference to a keyvalue in input\r\nfunction spl_rcRef (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\r\n    return reference;\r\n}\r\nexports.rcRef = spl_rcRef;\r\n\r\n// Sets a value of a keyvalue in input\r\nfunction spl_rcSet (reference, key, value)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \r\n    reference[keys[i]] = value;\r\n    return reference[keys[i]]\r\n}\r\nexports.rcSet = spl_rcSet;\r\n\r\n// Complete request\r\nexports.throwError = function ( input, message )\r\n{\r\n    spl_setContext ( input, \"action\", \"spl/error/catch\" );\r\n    spl_setConfig ( input, \"spl/error/catch\", \"message\", message );\r\n}\r\n\r\n// construct a forward slash path for platform internal use\r\nexports.URI = function ( ...args ) { \r\n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \"\" ) result.push ( args[i] );\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// wsExists checks the presence of a property and loads it when not\r\nexports.wsExists = function ( input, key, action, args, repeat ) {\r\n    const parts = action.split ( \"/\" );\r\n    if( spl_wsRef ( input, key ) === undefined ) {\r\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n        else spl_rcSet ( input.headers, parts.join ( \".\" ), [args] );\r\n        spl_setRequest ( input, `${parts[1]}_next`, action );\r\n        spl_setRequest ( input, \"status\", parts[1] );\r\n        spl_setRequest ( input, \"repeat\", repeat );\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// wsGet returns a deep clone of a keyvalue in input.value.\r\nexports.wsGet = function ( input, key ) { \r\n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) ) ); \r\n}\r\n\r\n// wsRef returns a reference to a keyvalue in input.value.\r\nfunction spl_wsRef (input, key) \r\n{ \r\n    const parts = key.split ( \".\" );\r\n    var value = spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) );\r\n    if ( typeof value == \"string\" && !( \"spl/blob spl/package\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\r\n    return value;\r\n}\r\nexports.wsRef = spl_wsRef;\r\n\r\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\r\nexports.wsSet = function (input, key, value)\r\n{ \r\n    const expandedKey = key.replaceAll ( \".\", \".value.\" );\r\n    const current = spl_rcRef ( input.value, expandedKey );\r\n    if( !( current === undefined ) ) {\r\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\r\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\r\n        archive.push(current);\r\n    }\r\n    spl_rcSet ( input.value, expandedKey, value );\r\n}\r\n",
    "/test-suite/data/test2-deployed/test2/modules/usr/noop.js": "//  name        No Operation\r\n//  URI         spl/usr/noop\r\n//  type        API Method\r\n//  description This command does not execute any action.\r\n//              It is included to facilitate testing.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_usr_noop (input) { \r\n    console.log ( \"This command does nothing.\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/test-suite/data/test2-deployed/test2/modules/usr/noop_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"usr/noop\" },\r\n            { \"content\": \"The null operation.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> usr/noop <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/test-suite/data/test2-deployed/test2/scripts/spl2.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst clientRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = { \r\n    action: \"spl/execute/initialise\", \r\n    consoleProgress: \"start\",\r\n    consoleMode: \"standard\", // silent, warning, verbose, debug \r\n    runtimeMode: \"silent\",\r\n    cwd: splRoot, \r\n    session: session, \r\n    modules: \"../modules\", \r\n    TTL: 170 };\r\nconst action = \"spl/command/execute\";\r\nconst config = {\r\n    set: {\r\n        commandString: commandString,\r\n        template: { repo: clientRoot, dir: \"commands\", file: \"command.json\", copy: [ \"spl/command\" ] }\r\n    }\r\n};\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, \"spl/command/execute\", null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n\r\n",
    "/test-suite/data/test2-deployed/test2/spl": "node spl.js $@\r\n",
    "/test-suite/data/test2-deployed/test2/spl.cmd": "node spl.js %*\r\n",
    "/test-suite/data/test2-deployed/test2/spl.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst appRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = {   action: \"spl/execute/initialise\", consoleProgress: \"start\",  consoleMode: \"debug\", // silent, standard, warning, verbose, debug \r\n                    runtimeMode: \"silent\", cwd: splRoot, session: session, modules: \"../modules\", moduleOverlay: [{ prefix: \"usr\", moduleRoot: `${appRoot}/modules` }], TTL: 100 };\r\nconst action = \"spl/app/process\";\r\nconst batch = commandString;\r\n/*`spl/console/log hello world _!_ spl/console/error hello world 2\r\n -h    usr/noop \r\n -s 10  spl/app/exec -f simple-batch\r\nspl/app -h run -f testscript.js\r\nspl -h app/reset`;*/\r\nconst config = { appRoot: appRoot, batch: batch };\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, action, null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n",
    "/test-suite/data/test2-deployed/test2/spl2.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst clientRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = { \r\n    action: \"spl/execute/initialise\", \r\n    consoleProgress: \"start\",\r\n    consoleMode: \"standard\", // silent, warning, verbose, debug \r\n    runtimeMode: \"silent\",\r\n    cwd: splRoot, \r\n    session: session, \r\n    modules: \"../modules\", \r\n    TTL: 170 };\r\nconst action = \"spl/command/execute\";\r\nconst config = {\r\n    set: {\r\n        commandString: commandString,\r\n        template: { repo: clientRoot, dir: \"commands\", file: \"command.json\", copy: [ \"spl/command\" ] }\r\n    }\r\n};\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, \"spl/command/execute\", null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n\r\n",
    "/test-suite/data/test2-deployed/test2/splappstest-suite/": {},
    "/test-suite/modules/arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"top\" : [\r\n            { \"header\": \"SPlectrum Test App\" },\r\n            { \"content\": \"A client used to test the current package functionaltiy.\" }\r\n        ],\r\n        \"header\": [\r\n            { \"content\": \"Overview 1.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <options> <package>}\" }\r\n        ],\r\n        \"bottom\": [ \r\n            { \"content\": \"Project home: {underline https://github.com/SPlectrum/spl}\" } ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"test\", \"alias\": \"t\", \"type\": \"Boolean\", \"description\": \"test - parse commands but do not execute.\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"steps\", \"alias\": \"s\", \"type\": \"Number\", \"description\": \"TTL of the command execution.\"},\r\n        { \"name\": \"verbose\", \"alias\": \"v\", \"type\": \"Boolean\", \"description\": \"Do verbose output on completion.\"},\r\n        { \"name\": \"debug\", \"alias\": \"d\", \"type\": \"Boolean\", \"description\": \"Do debug output on completion.\"}\r\n    ]\r\n}\r\n",
    "/test-suite/modules/spl.js": "//  name        SPL Package Useful Functions\r\n//  URI         spl/spl\r\n//  type        Auxiliary Library\r\n//  description Library of auxiliary methods at package level\r\n//              It contains methods to invoke actions, set properties and\r\n//              interacts with the workspace.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst { randomUUID } = require('crypto');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Gets a configuration value associated with the action currently being executed\r\nfunction spl_action ( input, key )\r\n{\r\n    // get the current action\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_config ( input, action, key );\r\n}\r\nexports.action = spl_action;\r\n\r\n// Gets a configuration value for the specified action\r\nfunction spl_config ( input, action, key )\r\n{\r\n    // split the current action ( request or execute )\r\n    var parts = parts = action.split ( \"/\" ), result, entry;\r\n    const apiRef = `${parts[0]}.${parts[1]}`;\r\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\r\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\r\n    const methodRefUri = action;\r\n\r\n    // first: check execution header for method config\r\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\r\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // second: check workspace method entry header for method config\r\n    entry = spl_wsRef ( input, methodRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // third: check workspace API entry header  for method config\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // no API default for full method property set\r\n    if ( key === undefined ) return result; // no default\r\n\r\n    // fourth: check execution header for API config (default)\r\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n    \r\n    // fifth: check workspace API entry header for API config (default)\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, apiRef );\r\n        if ( !( result === undefined ) ) result = result[key];\r\n    }\r\n    return result;\r\n}\r\nexports.config = spl_config;\r\n\r\n// get execution context properties\r\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\r\nexports.context = spl_context;\r\n\r\n// get request properties only ( spl/execute/request )\r\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\r\nexports.request = spl_request;\r\n\r\n// set current action specific properties \r\nfunction spl_setAction ( input, key, value ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_setConfig ( input, action, key, value );\r\n}\r\nexports.setAction = spl_setAction;\r\n\r\n// set method / api specific properties \r\nfunction spl_setConfig ( input, action, key, value ) {\r\n    action = action.replaceAll ( \"/\", \".\" );\r\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\r\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\r\n}\r\nexports.setConfig = spl_setConfig;\r\n\r\n// set execution context properties\r\nfunction spl_setContext ( input, key, value ) { \r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.execute\", value ); \r\n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \r\n}\r\nexports.setContext = spl_setContext;\r\n\r\n// set request properties only ( spl/execute/request )\r\nfunction spl_setRequest ( input, key, value ) {\r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.request\", value );\r\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\r\n}\r\nexports.setRequest = spl_setRequest;\r\n\r\n// Complete request\r\nexports.completed = function ( input ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) {\r\n        action = spl_request ( input, \"action\" );\r\n        spl_setRequest ( input, \"status\", \"completed\" );\r\n    } else {\r\n        action = spl_context ( input, \"action\" );\r\n        spl_setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n    }\r\n    spl_rcDelete ( input.headers, action.replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\r\nexports.fURI = function ( ... args ) { \r\n    args[args.length-1] = args[args.length-1].replaceAll ( \".\", \"_\" );\r\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \"\") result.push(args[i]);;\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// random UUID generation\r\nfunction generateUUID() { return randomUUID(); }\r\nexports.generateUUID = generateUUID;\r\n\r\n// wsAction sets an action for the execution context\r\nexports.gotoExecute = function ( input, action, args )\r\n{\r\n    var parts = action.split ( \"/\" );\r\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n    spl_setRequest ( input, `${parts[1]}_next`, action );\r\n    spl_setRequest ( input, \"status\", parts[1] );\r\n    spl_setRequest ( input, \"repeat\", false );\r\n    spl_request ( input, \"action\" ); //.split ( \"/\" );\r\n    spl_rcDelete ( input.headers, spl_request ( input, \"action\" ).replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// add to execution history\r\nexports.history = function ( input, activity )\r\n{\r\n    const action = spl_request ( input, \"action\" ); \r\n    var message = [ action, spl_context ( input, \"action\" ), activity ];\r\n    var history = spl_context ( input, \"history\" );\r\n    if ( history === undefined ) history = spl_setContext ( input, \"history\", [] );\r\n    history.push ( message );\r\n    var consoleProgress = spl_context ( input, \"consoleProgress\" );\r\n    if ( consoleProgress && consoleProgress != action )\r\n    {\r\n        consoleProgress = action;\r\n        console.log ( ` > ${consoleProgress}` );\r\n        spl_setContext ( input, \"consoleProgress\", consoleProgress );\r\n    }\r\n    if ( activity.substring ( 0, 5 ) == \"ERROR\" ) console.error ( message.join ( \" - \" ) );\r\n    else if ( spl_context ( input, \"consoleMode\" ) != \"silent\" && activity.substring ( 0, 7 ) == \"WARNING\" ) console.error ( message.join ( \" - \" ) );\r\n}\r\n\r\n// easy functions to invoke actions\r\nexports.moduleAction = function (input, module)\r\n{\r\n    var moduleRoot = spl_context ( input, \"modules\" );\r\n    if ( moduleRoot === undefined ) moduleRoot = \"modules\";\r\n    var moduleOverlay = spl_context ( input, \"moduleOverlay\" );\r\n    if ( moduleOverlay )\r\n        for ( var i = 0; i < moduleOverlay.length; i++ )\r\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\r\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\r\n    return require ( `${ spl_context ( input, \"cwd\" )}/${moduleRoot}/${module}`).default ( input );\r\n}\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcDelete (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length - 1; i++)\r\n    {\r\n        if(reference[keys[i]]==undefined) return;\r\n        reference = reference[keys[i]];\r\n    }\r\n    delete reference[keys[i]];\r\n}\r\nexports.rcDelete = spl_rcDelete;\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\r\nexports.rcGet = spl_rcGet;\r\n\r\n// gets a reference to a keyvalue in input\r\nfunction spl_rcRef (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\r\n    return reference;\r\n}\r\nexports.rcRef = spl_rcRef;\r\n\r\n// Sets a value of a keyvalue in input\r\nfunction spl_rcSet (reference, key, value)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \r\n    reference[keys[i]] = value;\r\n    return reference[keys[i]]\r\n}\r\nexports.rcSet = spl_rcSet;\r\n\r\n// Complete request\r\nexports.throwError = function ( input, message )\r\n{\r\n    spl_setContext ( input, \"action\", \"spl/error/catch\" );\r\n    spl_setConfig ( input, \"spl/error/catch\", \"message\", message );\r\n}\r\n\r\n// construct a forward slash path for platform internal use\r\nexports.URI = function ( ...args ) { \r\n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \"\" ) result.push ( args[i] );\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// wsExists checks the presence of a property and loads it when not\r\nexports.wsExists = function ( input, key, action, args, repeat ) {\r\n    const parts = action.split ( \"/\" );\r\n    if( spl_wsRef ( input, key ) === undefined ) {\r\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n        else spl_rcSet ( input.headers, parts.join ( \".\" ), [args] );\r\n        spl_setRequest ( input, `${parts[1]}_next`, action );\r\n        spl_setRequest ( input, \"status\", parts[1] );\r\n        spl_setRequest ( input, \"repeat\", repeat );\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// wsGet returns a deep clone of a keyvalue in input.value.\r\nexports.wsGet = function ( input, key ) { \r\n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) ) ); \r\n}\r\n\r\n// wsRef returns a reference to a keyvalue in input.value.\r\nfunction spl_wsRef (input, key) \r\n{ \r\n    const parts = key.split ( \".\" );\r\n    var value = spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) );\r\n    if ( typeof value == \"string\" && !( \"spl/blob spl/package\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\r\n    return value;\r\n}\r\nexports.wsRef = spl_wsRef;\r\n\r\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\r\nexports.wsSet = function (input, key, value)\r\n{ \r\n    const expandedKey = key.replaceAll ( \".\", \".value.\" );\r\n    const current = spl_rcRef ( input.value, expandedKey );\r\n    if( !( current === undefined ) ) {\r\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\r\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\r\n        archive.push(current);\r\n    }\r\n    spl_rcSet ( input.value, expandedKey, value );\r\n}\r\n",
    "/test-suite/modules/usr/noop.js": "//  name        No Operation\r\n//  URI         spl/usr/noop\r\n//  type        API Method\r\n//  description This command does not execute any action.\r\n//              It is included to facilitate testing.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function spl_usr_noop (input) { \r\n    console.log ( \"This command does nothing.\" );\r\n    spl.completed ( input );\r\n}\r\n///////////////////////////////////////////////////////////////////////////////\r\n",
    "/test-suite/modules/usr/noop_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"usr/noop\" },\r\n            { \"content\": \"The null operation.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOptions> usr/noop <options>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help informatiion\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/test-suite/packages/test2-package.json": "{\n  \"headers\": {\n    \"spl\": {\n      \"package\": {\n        \"name\": \"test2-package.json\"\n      }\n    }\n  },\n  \"value\": {\n    \"/test2/actions/\": {},\n    \"/test2/batches/test-commands.txt\": \"spl/console/log Testing file-based command execution\\r\\nspl/console/log This is line 2\\r\\nspl/console/warn This is a warning message\\r\\nspl/console/log Final line from file\",\n    \"/test2/commands/requests/\": {},\n    \"/test2/commands/responses/\": {},\n    \"/test2/modules/arguments.json\": \"{\\r\\n    \\\"headers\\\": \\r\\n    {\\r\\n        \\\"top\\\" : [\\r\\n            { \\\"header\\\": \\\"SPlectrum Test App\\\" },\\r\\n            { \\\"content\\\": \\\"A client used to test the current package functionaltiy.\\\" }\\r\\n        ],\\r\\n        \\\"header\\\": [\\r\\n            { \\\"content\\\": \\\"Overview 1.\\\" },\\r\\n            { \\\"content\\\": \\\"{bold syntax}: {italic ./spl <options> <package>}\\\" }\\r\\n        ],\\r\\n        \\\"bottom\\\": [ \\r\\n            { \\\"content\\\": \\\"Project home: {underline https://github.com/SPlectrum/spl}\\\" } ]\\r\\n    },\\r\\n    \\\"value\\\": \\r\\n    [ \\r\\n        { \\\"name\\\": \\\"help\\\", \\\"alias\\\": \\\"h\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"show help information\\\", \\\"typeLabel\\\": \\\"flag\\\" }, \\r\\n        { \\\"name\\\": \\\"test\\\", \\\"alias\\\": \\\"t\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"test - parse commands but do not execute.\\\", \\\"typeLabel\\\": \\\"flag\\\" }, \\r\\n        { \\\"name\\\": \\\"steps\\\", \\\"alias\\\": \\\"s\\\", \\\"type\\\": \\\"Number\\\", \\\"description\\\": \\\"TTL of the command execution.\\\"},\\r\\n        { \\\"name\\\": \\\"verbose\\\", \\\"alias\\\": \\\"v\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"Do verbose output on completion.\\\"},\\r\\n        { \\\"name\\\": \\\"debug\\\", \\\"alias\\\": \\\"d\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"Do debug output on completion.\\\"}\\r\\n    ]\\r\\n}\\r\\n\",\n    \"/test2/modules/spl.js\": \"//  name        SPL Package Useful Functions\\r\\n//  URI         spl/spl\\r\\n//  type        Auxiliary Library\\r\\n//  description Library of auxiliary methods at package level\\r\\n//              It contains methods to invoke actions, set properties and\\r\\n//              interacts with the workspace.\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst { randomUUID } = require('crypto');\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n// Gets a configuration value associated with the action currently being executed\\r\\nfunction spl_action ( input, key )\\r\\n{\\r\\n    // get the current action\\r\\n    var action;\\r\\n    if ( spl_context ( input, \\\"action\\\" ) === \\\"spl/execute/next\\\" ) action = spl_request ( input, \\\"action\\\");\\r\\n    else action = spl_context ( input, \\\"action\\\" );\\r\\n    return spl_config ( input, action, key );\\r\\n}\\r\\nexports.action = spl_action;\\r\\n\\r\\n// Gets a configuration value for the specified action\\r\\nfunction spl_config ( input, action, key )\\r\\n{\\r\\n    // split the current action ( request or execute )\\r\\n    var parts = parts = action.split ( \\\"/\\\" ), result, entry;\\r\\n    const apiRef = `${parts[0]}.${parts[1]}`;\\r\\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\\r\\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\\r\\n    const methodRefUri = action;\\r\\n\\r\\n    // first: check execution header for method config\\r\\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\\r\\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n\\r\\n    // second: check workspace method entry header for method config\\r\\n    entry = spl_wsRef ( input, methodRefUri );\\r\\n    if ( entry && entry.headers ) {\\r\\n        result = spl_rcRef ( entry.headers, methodRef );\\r\\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\\r\\n    }\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n\\r\\n    // third: check workspace API entry header  for method config\\r\\n    entry = spl_wsRef ( input, apiRefUri );\\r\\n    if ( entry && entry.headers ) {\\r\\n        result = spl_rcRef ( entry.headers, methodRef );\\r\\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\\r\\n    }\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n\\r\\n    // no API default for full method property set\\r\\n    if ( key === undefined ) return result; // no default\\r\\n\\r\\n    // fourth: check execution header for API config (default)\\r\\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n    \\r\\n    // fifth: check workspace API entry header for API config (default)\\r\\n    entry = spl_wsRef ( input, apiRefUri );\\r\\n    if ( entry && entry.headers ) {\\r\\n        result = spl_rcRef ( entry.headers, apiRef );\\r\\n        if ( !( result === undefined ) ) result = result[key];\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\nexports.config = spl_config;\\r\\n\\r\\n// get execution context properties\\r\\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\\r\\nexports.context = spl_context;\\r\\n\\r\\n// get request properties only ( spl/execute/request )\\r\\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\\r\\nexports.request = spl_request;\\r\\n\\r\\n// set current action specific properties \\r\\nfunction spl_setAction ( input, key, value ) {\\r\\n    var action;\\r\\n    if ( spl_context ( input, \\\"action\\\" ) === \\\"spl/execute/next\\\" ) action = spl_request ( input, \\\"action\\\");\\r\\n    else action = spl_context ( input, \\\"action\\\" );\\r\\n    return spl_setConfig ( input, action, key, value );\\r\\n}\\r\\nexports.setAction = spl_setAction;\\r\\n\\r\\n// set method / api specific properties \\r\\nfunction spl_setConfig ( input, action, key, value ) {\\r\\n    action = action.replaceAll ( \\\"/\\\", \\\".\\\" );\\r\\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\\r\\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\\r\\n}\\r\\nexports.setConfig = spl_setConfig;\\r\\n\\r\\n// set execution context properties\\r\\nfunction spl_setContext ( input, key, value ) { \\r\\n    if ( key === null ) return spl_rcSet ( input, \\\"headers.spl.execute\\\", value ); \\r\\n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \\r\\n}\\r\\nexports.setContext = spl_setContext;\\r\\n\\r\\n// set request properties only ( spl/execute/request )\\r\\nfunction spl_setRequest ( input, key, value ) {\\r\\n    if ( key === null ) return spl_rcSet ( input, \\\"headers.spl.request\\\", value );\\r\\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\\r\\n}\\r\\nexports.setRequest = spl_setRequest;\\r\\n\\r\\n// Complete request\\r\\nexports.completed = function ( input ) {\\r\\n    var action;\\r\\n    if ( spl_context ( input, \\\"action\\\" ) === \\\"spl/execute/next\\\" ) {\\r\\n        action = spl_request ( input, \\\"action\\\" );\\r\\n        spl_setRequest ( input, \\\"status\\\", \\\"completed\\\" );\\r\\n    } else {\\r\\n        action = spl_context ( input, \\\"action\\\" );\\r\\n        spl_setContext ( input, \\\"action\\\", \\\"spl/execute/set-next\\\" );\\r\\n    }\\r\\n    spl_rcDelete ( input.headers, action.replaceAll ( \\\"/\\\", \\\".\\\" ) );\\r\\n}\\r\\n\\r\\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\\r\\nexports.fURI = function ( ... args ) { \\r\\n    args[args.length-1] = args[args.length-1].replaceAll ( \\\".\\\", \\\"_\\\" );\\r\\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \\\"\\\") result.push(args[i]);;\\r\\n    return result.join ( \\\"/\\\" );\\r\\n}\\r\\n\\r\\n// random UUID generation\\r\\nfunction generateUUID() { return randomUUID(); }\\r\\nexports.generateUUID = generateUUID;\\r\\n\\r\\n// wsAction sets an action for the execution context\\r\\nexports.gotoExecute = function ( input, action, args )\\r\\n{\\r\\n    var parts = action.split ( \\\"/\\\" );\\r\\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \\\".\\\" ), args );\\r\\n    spl_setRequest ( input, `${parts[1]}_next`, action );\\r\\n    spl_setRequest ( input, \\\"status\\\", parts[1] );\\r\\n    spl_setRequest ( input, \\\"repeat\\\", false );\\r\\n    spl_request ( input, \\\"action\\\" ); //.split ( \\\"/\\\" );\\r\\n    spl_rcDelete ( input.headers, spl_request ( input, \\\"action\\\" ).replaceAll ( \\\"/\\\", \\\".\\\" ) );\\r\\n}\\r\\n\\r\\n// add to execution history\\r\\nexports.history = function ( input, activity )\\r\\n{\\r\\n    const action = spl_request ( input, \\\"action\\\" ); \\r\\n    var message = [ action, spl_context ( input, \\\"action\\\" ), activity ];\\r\\n    var history = spl_context ( input, \\\"history\\\" );\\r\\n    if ( history === undefined ) history = spl_setContext ( input, \\\"history\\\", [] );\\r\\n    history.push ( message );\\r\\n    var consoleProgress = spl_context ( input, \\\"consoleProgress\\\" );\\r\\n    if ( consoleProgress && consoleProgress != action )\\r\\n    {\\r\\n        consoleProgress = action;\\r\\n        console.log ( ` > ${consoleProgress}` );\\r\\n        spl_setContext ( input, \\\"consoleProgress\\\", consoleProgress );\\r\\n    }\\r\\n    if ( activity.substring ( 0, 5 ) == \\\"ERROR\\\" ) console.error ( message.join ( \\\" - \\\" ) );\\r\\n    else if ( spl_context ( input, \\\"consoleMode\\\" ) != \\\"silent\\\" && activity.substring ( 0, 7 ) == \\\"WARNING\\\" ) console.error ( message.join ( \\\" - \\\" ) );\\r\\n}\\r\\n\\r\\n// easy functions to invoke actions\\r\\nexports.moduleAction = function (input, module)\\r\\n{\\r\\n    var moduleRoot = spl_context ( input, \\\"modules\\\" );\\r\\n    if ( moduleRoot === undefined ) moduleRoot = \\\"modules\\\";\\r\\n    var moduleOverlay = spl_context ( input, \\\"moduleOverlay\\\" );\\r\\n    if ( moduleOverlay )\\r\\n        for ( var i = 0; i < moduleOverlay.length; i++ )\\r\\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\\r\\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\\r\\n    return require ( `${ spl_context ( input, \\\"cwd\\\" )}/${moduleRoot}/${module}`).default ( input );\\r\\n}\\r\\n\\r\\n// gets a deep clone of a keyvalue in input\\r\\nfunction spl_rcDelete (reference, key)\\r\\n{ \\r\\n    const keys = key.split(\\\".\\\");\\r\\n    for( i = 0; i < keys.length - 1; i++)\\r\\n    {\\r\\n        if(reference[keys[i]]==undefined) return;\\r\\n        reference = reference[keys[i]];\\r\\n    }\\r\\n    delete reference[keys[i]];\\r\\n}\\r\\nexports.rcDelete = spl_rcDelete;\\r\\n\\r\\n// gets a deep clone of a keyvalue in input\\r\\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\\r\\nexports.rcGet = spl_rcGet;\\r\\n\\r\\n// gets a reference to a keyvalue in input\\r\\nfunction spl_rcRef (reference, key)\\r\\n{ \\r\\n    const keys = key.split(\\\".\\\");\\r\\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\\r\\n    return reference;\\r\\n}\\r\\nexports.rcRef = spl_rcRef;\\r\\n\\r\\n// Sets a value of a keyvalue in input\\r\\nfunction spl_rcSet (reference, key, value)\\r\\n{ \\r\\n    const keys = key.split(\\\".\\\");\\r\\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \\r\\n    reference[keys[i]] = value;\\r\\n    return reference[keys[i]]\\r\\n}\\r\\nexports.rcSet = spl_rcSet;\\r\\n\\r\\n// Complete request\\r\\nexports.throwError = function ( input, message )\\r\\n{\\r\\n    spl_setContext ( input, \\\"action\\\", \\\"spl/error/catch\\\" );\\r\\n    spl_setConfig ( input, \\\"spl/error/catch\\\", \\\"message\\\", message );\\r\\n}\\r\\n\\r\\n// construct a forward slash path for platform internal use\\r\\nexports.URI = function ( ...args ) { \\r\\n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \\\"\\\" ) result.push ( args[i] );\\r\\n    return result.join ( \\\"/\\\" );\\r\\n}\\r\\n\\r\\n// wsExists checks the presence of a property and loads it when not\\r\\nexports.wsExists = function ( input, key, action, args, repeat ) {\\r\\n    const parts = action.split ( \\\"/\\\" );\\r\\n    if( spl_wsRef ( input, key ) === undefined ) {\\r\\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \\\".\\\" ), args );\\r\\n        else spl_rcSet ( input.headers, parts.join ( \\\".\\\" ), [args] );\\r\\n        spl_setRequest ( input, `${parts[1]}_next`, action );\\r\\n        spl_setRequest ( input, \\\"status\\\", parts[1] );\\r\\n        spl_setRequest ( input, \\\"repeat\\\", repeat );\\r\\n        return false;\\r\\n    }\\r\\n    return true;\\r\\n}\\r\\n\\r\\n// wsGet returns a deep clone of a keyvalue in input.value.\\r\\nexports.wsGet = function ( input, key ) { \\r\\n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \\\".\\\", \\\".value.\\\" ) ) ); \\r\\n}\\r\\n\\r\\n// wsRef returns a reference to a keyvalue in input.value.\\r\\nfunction spl_wsRef (input, key) \\r\\n{ \\r\\n    const parts = key.split ( \\\".\\\" );\\r\\n    var value = spl_rcRef ( input.value, key.replaceAll ( \\\".\\\", \\\".value.\\\" ) );\\r\\n    if ( typeof value == \\\"string\\\" && !( \\\"spl/blob spl/package\\\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\\r\\n    return value;\\r\\n}\\r\\nexports.wsRef = spl_wsRef;\\r\\n\\r\\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\\r\\nexports.wsSet = function (input, key, value)\\r\\n{ \\r\\n    const expandedKey = key.replaceAll ( \\\".\\\", \\\".value.\\\" );\\r\\n    const current = spl_rcRef ( input.value, expandedKey );\\r\\n    if( !( current === undefined ) ) {\\r\\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\\r\\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\\r\\n        archive.push(current);\\r\\n    }\\r\\n    spl_rcSet ( input.value, expandedKey, value );\\r\\n}\\r\\n\",\n    \"/test2/modules/usr/noop.js\": \"//  name        No Operation\\r\\n//  URI         spl/usr/noop\\r\\n//  type        API Method\\r\\n//  description This command does not execute any action.\\r\\n//              It is included to facilitate testing.\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst spl = require(\\\"../spl.js\\\")\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nexports.default = function spl_usr_noop (input) { \\r\\n    console.log ( \\\"This command does nothing.\\\" );\\r\\n    spl.completed ( input );\\r\\n}\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n\",\n    \"/test2/modules/usr/noop_arguments.json\": \"{\\r\\n    \\\"headers\\\": \\r\\n    {\\r\\n        \\\"header\\\": \\r\\n        [\\r\\n            { \\\"header\\\": \\\"usr/noop\\\" },\\r\\n            { \\\"content\\\": \\\"The null operation.\\\" },\\r\\n            { \\\"content\\\": \\\"{bold syntax}: {italic ./spl <appOptions> usr/noop <options>}\\\" }\\r\\n]\\r\\n    },\\r\\n    \\\"value\\\": \\r\\n    [ \\r\\n        { \\\"name\\\": \\\"help\\\", \\\"alias\\\": \\\"h\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"show help informatiion\\\", \\\"typeLabel\\\": \\\"flag\\\" }\\r\\n    ]\\r\\n}\\r\\n\",\n    \"/test2/scripts/spl2.js\": \"const spl = require(\\\"../../../modules/spl/spl.js\\\");\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n// Set SPlectrum and client root directory, extract command string\\r\\nvar root = process.cwd().split(\\\"/\\\");\\r\\nif (root.length === 1 ) root = root[0].split(`\\\\\\\\`);\\r\\nconst splRoot = root.slice(0,root.length-2).join(\\\"/\\\");\\r\\nconst session = root[root.length-1];\\r\\nconst clientRoot = root.slice(root.length - 2).join(\\\"/\\\")\\r\\nconst commandString = process.argv.slice(2);\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst context = { \\r\\n    action: \\\"spl/execute/initialise\\\", \\r\\n    consoleProgress: \\\"start\\\",\\r\\n    consoleMode: \\\"standard\\\", // silent, warning, verbose, debug \\r\\n    runtimeMode: \\\"silent\\\",\\r\\n    cwd: splRoot, \\r\\n    session: session, \\r\\n    modules: \\\"../modules\\\", \\r\\n    TTL: 170 };\\r\\nconst action = \\\"spl/command/execute\\\";\\r\\nconst config = {\\r\\n    set: {\\r\\n        commandString: commandString,\\r\\n        template: { repo: clientRoot, dir: \\\"commands\\\", file: \\\"command.json\\\", copy: [ \\\"spl/command\\\" ] }\\r\\n    }\\r\\n};\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nvar command = { headers: {}, value: {} }\\r\\nspl.setContext ( command, null, context );\\r\\nspl.setRequest ( command, \\\"action\\\", action );\\r\\nspl.setConfig ( command, \\\"spl/command/execute\\\", null, config );\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nspl.moduleAction( command, \\\"spl/execute/execute\\\" );\\r\\n\\r\\n\",\n    \"/test2/spl\": \"node spl.js $@\\r\\n\",\n    \"/test2/spl.cmd\": \"node spl.js %*\\r\\n\",\n    \"/test2/spl.js\": \"const spl = require(\\\"../../../modules/spl/spl.js\\\");\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n// Set SPlectrum and client root directory, extract command string\\r\\nvar root = process.cwd().split(\\\"/\\\");\\r\\nif (root.length === 1 ) root = root[0].split(`\\\\\\\\`);\\r\\nconst splRoot = root.slice(0,root.length-2).join(\\\"/\\\");\\r\\nconst session = root[root.length-1];\\r\\nconst appRoot = root.slice(root.length - 2).join(\\\"/\\\")\\r\\nconst commandString = process.argv.slice(2);\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst context = {   action: \\\"spl/execute/initialise\\\", consoleProgress: \\\"start\\\",  consoleMode: \\\"debug\\\", // silent, standard, warning, verbose, debug \\r\\n                    runtimeMode: \\\"silent\\\", cwd: splRoot, session: session, modules: \\\"../modules\\\", moduleOverlay: [{ prefix: \\\"usr\\\", moduleRoot: `${appRoot}/modules` }], TTL: 100 };\\r\\nconst action = \\\"spl/app/process\\\";\\r\\nconst batch = commandString;\\r\\n/*`spl/console/log hello world _!_ spl/console/error hello world 2\\r\\n -h    usr/noop \\r\\n -s 10  spl/app/exec -f simple-batch\\r\\nspl/app -h run -f testscript.js\\r\\nspl -h app/reset`;*/\\r\\nconst config = { appRoot: appRoot, batch: batch };\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nvar command = { headers: {}, value: {} }\\r\\nspl.setContext ( command, null, context );\\r\\nspl.setRequest ( command, \\\"action\\\", action );\\r\\nspl.setConfig ( command, action, null, config );\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nspl.moduleAction( command, \\\"spl/execute/execute\\\" );\\r\\n\",\n    \"/test2/spl2.js\": \"const spl = require(\\\"../../../modules/spl/spl.js\\\");\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n// Set SPlectrum and client root directory, extract command string\\r\\nvar root = process.cwd().split(\\\"/\\\");\\r\\nif (root.length === 1 ) root = root[0].split(`\\\\\\\\`);\\r\\nconst splRoot = root.slice(0,root.length-2).join(\\\"/\\\");\\r\\nconst session = root[root.length-1];\\r\\nconst clientRoot = root.slice(root.length - 2).join(\\\"/\\\")\\r\\nconst commandString = process.argv.slice(2);\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst context = { \\r\\n    action: \\\"spl/execute/initialise\\\", \\r\\n    consoleProgress: \\\"start\\\",\\r\\n    consoleMode: \\\"standard\\\", // silent, warning, verbose, debug \\r\\n    runtimeMode: \\\"silent\\\",\\r\\n    cwd: splRoot, \\r\\n    session: session, \\r\\n    modules: \\\"../modules\\\", \\r\\n    TTL: 170 };\\r\\nconst action = \\\"spl/command/execute\\\";\\r\\nconst config = {\\r\\n    set: {\\r\\n        commandString: commandString,\\r\\n        template: { repo: clientRoot, dir: \\\"commands\\\", file: \\\"command.json\\\", copy: [ \\\"spl/command\\\" ] }\\r\\n    }\\r\\n};\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nvar command = { headers: {}, value: {} }\\r\\nspl.setContext ( command, null, context );\\r\\nspl.setRequest ( command, \\\"action\\\", action );\\r\\nspl.setConfig ( command, \\\"spl/command/execute\\\", null, config );\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nspl.moduleAction( command, \\\"spl/execute/execute\\\" );\\r\\n\\r\\n\",\n    \"/test2/splappstest-suite/\": {}\n  }\n}",
    "/test-suite/packages/test2-package2.json": "{\n  \"headers\": {\n    \"spl\": {\n      \"package\": {\n        \"name\": \"test2-package2.json\"\n      }\n    }\n  },\n  \"value\": {\n    \"/test2/actions/\": {},\n    \"/test2/batches/test-commands.txt\": \"spl/console/log Testing file-based command execution\\r\\nspl/console/log This is line 2\\r\\nspl/console/warn This is a warning message\\r\\nspl/console/log Final line from file\",\n    \"/test2/commands/requests/\": {},\n    \"/test2/commands/responses/\": {},\n    \"/test2/modules/arguments.json\": \"{\\r\\n    \\\"headers\\\": \\r\\n    {\\r\\n        \\\"top\\\" : [\\r\\n            { \\\"header\\\": \\\"SPlectrum Test App\\\" },\\r\\n            { \\\"content\\\": \\\"A client used to test the current package functionaltiy.\\\" }\\r\\n        ],\\r\\n        \\\"header\\\": [\\r\\n            { \\\"content\\\": \\\"Overview 1.\\\" },\\r\\n            { \\\"content\\\": \\\"{bold syntax}: {italic ./spl <options> <package>}\\\" }\\r\\n        ],\\r\\n        \\\"bottom\\\": [ \\r\\n            { \\\"content\\\": \\\"Project home: {underline https://github.com/SPlectrum/spl}\\\" } ]\\r\\n    },\\r\\n    \\\"value\\\": \\r\\n    [ \\r\\n        { \\\"name\\\": \\\"help\\\", \\\"alias\\\": \\\"h\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"show help information\\\", \\\"typeLabel\\\": \\\"flag\\\" }, \\r\\n        { \\\"name\\\": \\\"test\\\", \\\"alias\\\": \\\"t\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"test - parse commands but do not execute.\\\", \\\"typeLabel\\\": \\\"flag\\\" }, \\r\\n        { \\\"name\\\": \\\"steps\\\", \\\"alias\\\": \\\"s\\\", \\\"type\\\": \\\"Number\\\", \\\"description\\\": \\\"TTL of the command execution.\\\"},\\r\\n        { \\\"name\\\": \\\"verbose\\\", \\\"alias\\\": \\\"v\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"Do verbose output on completion.\\\"},\\r\\n        { \\\"name\\\": \\\"debug\\\", \\\"alias\\\": \\\"d\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"Do debug output on completion.\\\"}\\r\\n    ]\\r\\n}\\r\\n\",\n    \"/test2/modules/spl.js\": \"//  name        SPL Package Useful Functions\\r\\n//  URI         spl/spl\\r\\n//  type        Auxiliary Library\\r\\n//  description Library of auxiliary methods at package level\\r\\n//              It contains methods to invoke actions, set properties and\\r\\n//              interacts with the workspace.\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst { randomUUID } = require('crypto');\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n// Gets a configuration value associated with the action currently being executed\\r\\nfunction spl_action ( input, key )\\r\\n{\\r\\n    // get the current action\\r\\n    var action;\\r\\n    if ( spl_context ( input, \\\"action\\\" ) === \\\"spl/execute/next\\\" ) action = spl_request ( input, \\\"action\\\");\\r\\n    else action = spl_context ( input, \\\"action\\\" );\\r\\n    return spl_config ( input, action, key );\\r\\n}\\r\\nexports.action = spl_action;\\r\\n\\r\\n// Gets a configuration value for the specified action\\r\\nfunction spl_config ( input, action, key )\\r\\n{\\r\\n    // split the current action ( request or execute )\\r\\n    var parts = parts = action.split ( \\\"/\\\" ), result, entry;\\r\\n    const apiRef = `${parts[0]}.${parts[1]}`;\\r\\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\\r\\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\\r\\n    const methodRefUri = action;\\r\\n\\r\\n    // first: check execution header for method config\\r\\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\\r\\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n\\r\\n    // second: check workspace method entry header for method config\\r\\n    entry = spl_wsRef ( input, methodRefUri );\\r\\n    if ( entry && entry.headers ) {\\r\\n        result = spl_rcRef ( entry.headers, methodRef );\\r\\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\\r\\n    }\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n\\r\\n    // third: check workspace API entry header  for method config\\r\\n    entry = spl_wsRef ( input, apiRefUri );\\r\\n    if ( entry && entry.headers ) {\\r\\n        result = spl_rcRef ( entry.headers, methodRef );\\r\\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\\r\\n    }\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n\\r\\n    // no API default for full method property set\\r\\n    if ( key === undefined ) return result; // no default\\r\\n\\r\\n    // fourth: check execution header for API config (default)\\r\\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\\r\\n    if ( !( result === undefined ) ) return result;\\r\\n    \\r\\n    // fifth: check workspace API entry header for API config (default)\\r\\n    entry = spl_wsRef ( input, apiRefUri );\\r\\n    if ( entry && entry.headers ) {\\r\\n        result = spl_rcRef ( entry.headers, apiRef );\\r\\n        if ( !( result === undefined ) ) result = result[key];\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\nexports.config = spl_config;\\r\\n\\r\\n// get execution context properties\\r\\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\\r\\nexports.context = spl_context;\\r\\n\\r\\n// get request properties only ( spl/execute/request )\\r\\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\\r\\nexports.request = spl_request;\\r\\n\\r\\n// set current action specific properties \\r\\nfunction spl_setAction ( input, key, value ) {\\r\\n    var action;\\r\\n    if ( spl_context ( input, \\\"action\\\" ) === \\\"spl/execute/next\\\" ) action = spl_request ( input, \\\"action\\\");\\r\\n    else action = spl_context ( input, \\\"action\\\" );\\r\\n    return spl_setConfig ( input, action, key, value );\\r\\n}\\r\\nexports.setAction = spl_setAction;\\r\\n\\r\\n// set method / api specific properties \\r\\nfunction spl_setConfig ( input, action, key, value ) {\\r\\n    action = action.replaceAll ( \\\"/\\\", \\\".\\\" );\\r\\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\\r\\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\\r\\n}\\r\\nexports.setConfig = spl_setConfig;\\r\\n\\r\\n// set execution context properties\\r\\nfunction spl_setContext ( input, key, value ) { \\r\\n    if ( key === null ) return spl_rcSet ( input, \\\"headers.spl.execute\\\", value ); \\r\\n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \\r\\n}\\r\\nexports.setContext = spl_setContext;\\r\\n\\r\\n// set request properties only ( spl/execute/request )\\r\\nfunction spl_setRequest ( input, key, value ) {\\r\\n    if ( key === null ) return spl_rcSet ( input, \\\"headers.spl.request\\\", value );\\r\\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\\r\\n}\\r\\nexports.setRequest = spl_setRequest;\\r\\n\\r\\n// Complete request\\r\\nexports.completed = function ( input ) {\\r\\n    var action;\\r\\n    if ( spl_context ( input, \\\"action\\\" ) === \\\"spl/execute/next\\\" ) {\\r\\n        action = spl_request ( input, \\\"action\\\" );\\r\\n        spl_setRequest ( input, \\\"status\\\", \\\"completed\\\" );\\r\\n    } else {\\r\\n        action = spl_context ( input, \\\"action\\\" );\\r\\n        spl_setContext ( input, \\\"action\\\", \\\"spl/execute/set-next\\\" );\\r\\n    }\\r\\n    spl_rcDelete ( input.headers, action.replaceAll ( \\\"/\\\", \\\".\\\" ) );\\r\\n}\\r\\n\\r\\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\\r\\nexports.fURI = function ( ... args ) { \\r\\n    args[args.length-1] = args[args.length-1].replaceAll ( \\\".\\\", \\\"_\\\" );\\r\\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \\\"\\\") result.push(args[i]);;\\r\\n    return result.join ( \\\"/\\\" );\\r\\n}\\r\\n\\r\\n// random UUID generation\\r\\nfunction generateUUID() { return randomUUID(); }\\r\\nexports.generateUUID = generateUUID;\\r\\n\\r\\n// wsAction sets an action for the execution context\\r\\nexports.gotoExecute = function ( input, action, args )\\r\\n{\\r\\n    var parts = action.split ( \\\"/\\\" );\\r\\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \\\".\\\" ), args );\\r\\n    spl_setRequest ( input, `${parts[1]}_next`, action );\\r\\n    spl_setRequest ( input, \\\"status\\\", parts[1] );\\r\\n    spl_setRequest ( input, \\\"repeat\\\", false );\\r\\n    spl_request ( input, \\\"action\\\" ); //.split ( \\\"/\\\" );\\r\\n    spl_rcDelete ( input.headers, spl_request ( input, \\\"action\\\" ).replaceAll ( \\\"/\\\", \\\".\\\" ) );\\r\\n}\\r\\n\\r\\n// add to execution history\\r\\nexports.history = function ( input, activity )\\r\\n{\\r\\n    const action = spl_request ( input, \\\"action\\\" ); \\r\\n    var message = [ action, spl_context ( input, \\\"action\\\" ), activity ];\\r\\n    var history = spl_context ( input, \\\"history\\\" );\\r\\n    if ( history === undefined ) history = spl_setContext ( input, \\\"history\\\", [] );\\r\\n    history.push ( message );\\r\\n    var consoleProgress = spl_context ( input, \\\"consoleProgress\\\" );\\r\\n    if ( consoleProgress && consoleProgress != action )\\r\\n    {\\r\\n        consoleProgress = action;\\r\\n        console.log ( ` > ${consoleProgress}` );\\r\\n        spl_setContext ( input, \\\"consoleProgress\\\", consoleProgress );\\r\\n    }\\r\\n    if ( activity.substring ( 0, 5 ) == \\\"ERROR\\\" ) console.error ( message.join ( \\\" - \\\" ) );\\r\\n    else if ( spl_context ( input, \\\"consoleMode\\\" ) != \\\"silent\\\" && activity.substring ( 0, 7 ) == \\\"WARNING\\\" ) console.error ( message.join ( \\\" - \\\" ) );\\r\\n}\\r\\n\\r\\n// easy functions to invoke actions\\r\\nexports.moduleAction = function (input, module)\\r\\n{\\r\\n    var moduleRoot = spl_context ( input, \\\"modules\\\" );\\r\\n    if ( moduleRoot === undefined ) moduleRoot = \\\"modules\\\";\\r\\n    var moduleOverlay = spl_context ( input, \\\"moduleOverlay\\\" );\\r\\n    if ( moduleOverlay )\\r\\n        for ( var i = 0; i < moduleOverlay.length; i++ )\\r\\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\\r\\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\\r\\n    return require ( `${ spl_context ( input, \\\"cwd\\\" )}/${moduleRoot}/${module}`).default ( input );\\r\\n}\\r\\n\\r\\n// gets a deep clone of a keyvalue in input\\r\\nfunction spl_rcDelete (reference, key)\\r\\n{ \\r\\n    const keys = key.split(\\\".\\\");\\r\\n    for( i = 0; i < keys.length - 1; i++)\\r\\n    {\\r\\n        if(reference[keys[i]]==undefined) return;\\r\\n        reference = reference[keys[i]];\\r\\n    }\\r\\n    delete reference[keys[i]];\\r\\n}\\r\\nexports.rcDelete = spl_rcDelete;\\r\\n\\r\\n// gets a deep clone of a keyvalue in input\\r\\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\\r\\nexports.rcGet = spl_rcGet;\\r\\n\\r\\n// gets a reference to a keyvalue in input\\r\\nfunction spl_rcRef (reference, key)\\r\\n{ \\r\\n    const keys = key.split(\\\".\\\");\\r\\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\\r\\n    return reference;\\r\\n}\\r\\nexports.rcRef = spl_rcRef;\\r\\n\\r\\n// Sets a value of a keyvalue in input\\r\\nfunction spl_rcSet (reference, key, value)\\r\\n{ \\r\\n    const keys = key.split(\\\".\\\");\\r\\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \\r\\n    reference[keys[i]] = value;\\r\\n    return reference[keys[i]]\\r\\n}\\r\\nexports.rcSet = spl_rcSet;\\r\\n\\r\\n// Complete request\\r\\nexports.throwError = function ( input, message )\\r\\n{\\r\\n    spl_setContext ( input, \\\"action\\\", \\\"spl/error/catch\\\" );\\r\\n    spl_setConfig ( input, \\\"spl/error/catch\\\", \\\"message\\\", message );\\r\\n}\\r\\n\\r\\n// construct a forward slash path for platform internal use\\r\\nexports.URI = function ( ...args ) { \\r\\n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \\\"\\\" ) result.push ( args[i] );\\r\\n    return result.join ( \\\"/\\\" );\\r\\n}\\r\\n\\r\\n// wsExists checks the presence of a property and loads it when not\\r\\nexports.wsExists = function ( input, key, action, args, repeat ) {\\r\\n    const parts = action.split ( \\\"/\\\" );\\r\\n    if( spl_wsRef ( input, key ) === undefined ) {\\r\\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \\\".\\\" ), args );\\r\\n        else spl_rcSet ( input.headers, parts.join ( \\\".\\\" ), [args] );\\r\\n        spl_setRequest ( input, `${parts[1]}_next`, action );\\r\\n        spl_setRequest ( input, \\\"status\\\", parts[1] );\\r\\n        spl_setRequest ( input, \\\"repeat\\\", repeat );\\r\\n        return false;\\r\\n    }\\r\\n    return true;\\r\\n}\\r\\n\\r\\n// wsGet returns a deep clone of a keyvalue in input.value.\\r\\nexports.wsGet = function ( input, key ) { \\r\\n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \\\".\\\", \\\".value.\\\" ) ) ); \\r\\n}\\r\\n\\r\\n// wsRef returns a reference to a keyvalue in input.value.\\r\\nfunction spl_wsRef (input, key) \\r\\n{ \\r\\n    const parts = key.split ( \\\".\\\" );\\r\\n    var value = spl_rcRef ( input.value, key.replaceAll ( \\\".\\\", \\\".value.\\\" ) );\\r\\n    if ( typeof value == \\\"string\\\" && !( \\\"spl/blob spl/package\\\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\\r\\n    return value;\\r\\n}\\r\\nexports.wsRef = spl_wsRef;\\r\\n\\r\\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\\r\\nexports.wsSet = function (input, key, value)\\r\\n{ \\r\\n    const expandedKey = key.replaceAll ( \\\".\\\", \\\".value.\\\" );\\r\\n    const current = spl_rcRef ( input.value, expandedKey );\\r\\n    if( !( current === undefined ) ) {\\r\\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\\r\\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\\r\\n        archive.push(current);\\r\\n    }\\r\\n    spl_rcSet ( input.value, expandedKey, value );\\r\\n}\\r\\n\",\n    \"/test2/modules/usr/noop.js\": \"//  name        No Operation\\r\\n//  URI         spl/usr/noop\\r\\n//  type        API Method\\r\\n//  description This command does not execute any action.\\r\\n//              It is included to facilitate testing.\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst spl = require(\\\"../spl.js\\\")\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nexports.default = function spl_usr_noop (input) { \\r\\n    console.log ( \\\"This command does nothing.\\\" );\\r\\n    spl.completed ( input );\\r\\n}\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n\",\n    \"/test2/modules/usr/noop_arguments.json\": \"{\\r\\n    \\\"headers\\\": \\r\\n    {\\r\\n        \\\"header\\\": \\r\\n        [\\r\\n            { \\\"header\\\": \\\"usr/noop\\\" },\\r\\n            { \\\"content\\\": \\\"The null operation.\\\" },\\r\\n            { \\\"content\\\": \\\"{bold syntax}: {italic ./spl <appOptions> usr/noop <options>}\\\" }\\r\\n]\\r\\n    },\\r\\n    \\\"value\\\": \\r\\n    [ \\r\\n        { \\\"name\\\": \\\"help\\\", \\\"alias\\\": \\\"h\\\", \\\"type\\\": \\\"Boolean\\\", \\\"description\\\": \\\"show help informatiion\\\", \\\"typeLabel\\\": \\\"flag\\\" }\\r\\n    ]\\r\\n}\\r\\n\",\n    \"/test2/scripts/spl2.js\": \"const spl = require(\\\"../../../modules/spl/spl.js\\\");\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n// Set SPlectrum and client root directory, extract command string\\r\\nvar root = process.cwd().split(\\\"/\\\");\\r\\nif (root.length === 1 ) root = root[0].split(`\\\\\\\\`);\\r\\nconst splRoot = root.slice(0,root.length-2).join(\\\"/\\\");\\r\\nconst session = root[root.length-1];\\r\\nconst clientRoot = root.slice(root.length - 2).join(\\\"/\\\")\\r\\nconst commandString = process.argv.slice(2);\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst context = { \\r\\n    action: \\\"spl/execute/initialise\\\", \\r\\n    consoleProgress: \\\"start\\\",\\r\\n    consoleMode: \\\"standard\\\", // silent, warning, verbose, debug \\r\\n    runtimeMode: \\\"silent\\\",\\r\\n    cwd: splRoot, \\r\\n    session: session, \\r\\n    modules: \\\"../modules\\\", \\r\\n    TTL: 170 };\\r\\nconst action = \\\"spl/command/execute\\\";\\r\\nconst config = {\\r\\n    set: {\\r\\n        commandString: commandString,\\r\\n        template: { repo: clientRoot, dir: \\\"commands\\\", file: \\\"command.json\\\", copy: [ \\\"spl/command\\\" ] }\\r\\n    }\\r\\n};\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nvar command = { headers: {}, value: {} }\\r\\nspl.setContext ( command, null, context );\\r\\nspl.setRequest ( command, \\\"action\\\", action );\\r\\nspl.setConfig ( command, \\\"spl/command/execute\\\", null, config );\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nspl.moduleAction( command, \\\"spl/execute/execute\\\" );\\r\\n\\r\\n\",\n    \"/test2/spl\": \"node spl.js $@\\r\\n\",\n    \"/test2/spl.cmd\": \"node spl.js %*\\r\\n\",\n    \"/test2/spl.js\": \"const spl = require(\\\"../../../modules/spl/spl.js\\\");\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n// Set SPlectrum and client root directory, extract command string\\r\\nvar root = process.cwd().split(\\\"/\\\");\\r\\nif (root.length === 1 ) root = root[0].split(`\\\\\\\\`);\\r\\nconst splRoot = root.slice(0,root.length-2).join(\\\"/\\\");\\r\\nconst session = root[root.length-1];\\r\\nconst appRoot = root.slice(root.length - 2).join(\\\"/\\\")\\r\\nconst commandString = process.argv.slice(2);\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst context = {   action: \\\"spl/execute/initialise\\\", consoleProgress: \\\"start\\\",  consoleMode: \\\"debug\\\", // silent, standard, warning, verbose, debug \\r\\n                    runtimeMode: \\\"silent\\\", cwd: splRoot, session: session, modules: \\\"../modules\\\", moduleOverlay: [{ prefix: \\\"usr\\\", moduleRoot: `${appRoot}/modules` }], TTL: 100 };\\r\\nconst action = \\\"spl/app/process\\\";\\r\\nconst batch = commandString;\\r\\n/*`spl/console/log hello world _!_ spl/console/error hello world 2\\r\\n -h    usr/noop \\r\\n -s 10  spl/app/exec -f simple-batch\\r\\nspl/app -h run -f testscript.js\\r\\nspl -h app/reset`;*/\\r\\nconst config = { appRoot: appRoot, batch: batch };\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nvar command = { headers: {}, value: {} }\\r\\nspl.setContext ( command, null, context );\\r\\nspl.setRequest ( command, \\\"action\\\", action );\\r\\nspl.setConfig ( command, action, null, config );\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nspl.moduleAction( command, \\\"spl/execute/execute\\\" );\\r\\n\",\n    \"/test2/spl2.js\": \"const spl = require(\\\"../../../modules/spl/spl.js\\\");\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\n// Set SPlectrum and client root directory, extract command string\\r\\nvar root = process.cwd().split(\\\"/\\\");\\r\\nif (root.length === 1 ) root = root[0].split(`\\\\\\\\`);\\r\\nconst splRoot = root.slice(0,root.length-2).join(\\\"/\\\");\\r\\nconst session = root[root.length-1];\\r\\nconst clientRoot = root.slice(root.length - 2).join(\\\"/\\\")\\r\\nconst commandString = process.argv.slice(2);\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nconst context = { \\r\\n    action: \\\"spl/execute/initialise\\\", \\r\\n    consoleProgress: \\\"start\\\",\\r\\n    consoleMode: \\\"standard\\\", // silent, warning, verbose, debug \\r\\n    runtimeMode: \\\"silent\\\",\\r\\n    cwd: splRoot, \\r\\n    session: session, \\r\\n    modules: \\\"../modules\\\", \\r\\n    TTL: 170 };\\r\\nconst action = \\\"spl/command/execute\\\";\\r\\nconst config = {\\r\\n    set: {\\r\\n        commandString: commandString,\\r\\n        template: { repo: clientRoot, dir: \\\"commands\\\", file: \\\"command.json\\\", copy: [ \\\"spl/command\\\" ] }\\r\\n    }\\r\\n};\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nvar command = { headers: {}, value: {} }\\r\\nspl.setContext ( command, null, context );\\r\\nspl.setRequest ( command, \\\"action\\\", action );\\r\\nspl.setConfig ( command, \\\"spl/command/execute\\\", null, config );\\r\\n///////////////////////////////////////////////////////////////////////////////\\r\\nspl.moduleAction( command, \\\"spl/execute/execute\\\" );\\r\\n\\r\\n\",\n    \"/test2/splappstest-suite/\": {}\n  }\n}",
    "/test-suite/scripts/spl2.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst clientRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = { \r\n    action: \"spl/execute/initialise\", \r\n    consoleProgress: \"start\",\r\n    consoleMode: \"standard\", // silent, warning, verbose, debug \r\n    runtimeMode: \"silent\",\r\n    cwd: splRoot, \r\n    session: session, \r\n    modules: \"../modules\", \r\n    TTL: 170 };\r\nconst action = \"spl/command/execute\";\r\nconst config = {\r\n    set: {\r\n        commandString: commandString,\r\n        template: { repo: clientRoot, dir: \"commands\", file: \"command.json\", copy: [ \"spl/command\" ] }\r\n    }\r\n};\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, \"spl/command/execute\", null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n\r\n",
    "/test-suite/spl": "node spl.js $@\r\n",
    "/test-suite/spl.cmd": "node spl.js %*\r\n",
    "/test-suite/spl.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst appRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = {   action: \"spl/execute/initialise\", consoleProgress: \"start\",  consoleMode: \"standard\", // silent, standard, warning, verbose, debug \r\n                    runtimeMode: \"silent\", cwd: splRoot, session: session, modules: \"../modules\", moduleOverlay: [{ prefix: \"usr\", moduleRoot: `${appRoot}/modules` }], TTL: 100 };\r\nconst action = \"spl/app/process\";\r\nconst batch = commandString;\r\n/*`spl/console/log hello world _!_ spl/console/error hello world 2\r\n -h    usr/noop \r\n -s 10  spl/app/exec -f simple-batch\r\nspl/app -h run -f testscript.js\r\nspl -h app/reset`;*/\r\nconst config = { appRoot: appRoot, batch: batch };\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, action, null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n",
    "/test-suite/spl2.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst clientRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = { \r\n    action: \"spl/execute/initialise\", \r\n    consoleProgress: \"start\",\r\n    consoleMode: \"standard\", // silent, warning, verbose, debug \r\n    runtimeMode: \"silent\",\r\n    cwd: splRoot, \r\n    session: session, \r\n    modules: \"../modules\", \r\n    TTL: 170 };\r\nconst action = \"spl/command/execute\";\r\nconst config = {\r\n    set: {\r\n        commandString: commandString,\r\n        template: { repo: clientRoot, dir: \"commands\", file: \"command.json\", copy: [ \"spl/command\" ] }\r\n    }\r\n};\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, \"spl/command/execute\", null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n\r\n"
  }
}