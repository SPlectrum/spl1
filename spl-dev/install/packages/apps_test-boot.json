{
  "headers": {
    "spl": {
      "package": {
        "name": "apps_test-boot.json"
      }
    }
  },
  "value": {
    "/test-boot/batches/": {},
    "/test-boot/data/": {},
    "/test-boot/modules/arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"top\" : [\r\n            { \"header\": \"SPlectrum Boot App Testing\" },\r\n            { \"content\": \"Testing and verification tools for the boot app functionality.\" }\r\n        ],\r\n        \"header\": [\r\n            { \"content\": \"Provides automated testing for boot app deployment, package management, and state verification.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <options> <test-method>}\" }\r\n        ],\r\n        \"bottom\": [ \r\n            { \"content\": \"Project home: {underline https://github.com/SPlectrum/spl}\" } ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"test\", \"alias\": \"t\", \"type\": \"Boolean\", \"description\": \"test - parse commands but do not execute.\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"steps\", \"alias\": \"s\", \"type\": \"Number\", \"description\": \"TTL of the command execution.\"},\r\n        { \"name\": \"verbose\", \"alias\": \"v\", \"type\": \"Boolean\", \"description\": \"Do verbose output on completion.\"},\r\n        { \"name\": \"debug\", \"alias\": \"d\", \"type\": \"Boolean\", \"description\": \"Do debug output on completion.\"}\r\n    ]\r\n}",
    "/test-boot/modules/spl.js": "//  name        SPL Package Useful Functions\n//  URI         spl/spl\n//  type        Auxiliary Library\n//  description Library of auxiliary methods at package level\n//              It contains methods to invoke actions, set properties and\n//              interacts with the workspace.\n///////////////////////////////////////////////////////////////////////////////\nconst { randomUUID } = require('crypto');\n///////////////////////////////////////////////////////////////////////////////\n\n// Gets a configuration value associated with the action currently being executed\nfunction spl_action ( input, key )\n{\n    // get the current action\n    var action;\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\n    else action = spl_context ( input, \"action\" );\n    return spl_config ( input, action, key );\n}\nexports.action = spl_action;\n\n// Gets a configuration value for the specified action\nfunction spl_config ( input, action, key )\n{\n    // split the current action ( request or execute )\n    var parts = parts = action.split ( \"/\" ), result, entry;\n    const apiRef = `${parts[0]}.${parts[1]}`;\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\n    const methodRefUri = action;\n\n    // first: check execution header for method config\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\n    if ( !( result === undefined ) ) return result;\n\n    // second: check workspace method entry header for method config\n    entry = spl_wsRef ( input, methodRefUri );\n    if ( entry && entry.headers ) {\n        result = spl_rcRef ( entry.headers, methodRef );\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\n    }\n    if ( !( result === undefined ) ) return result;\n\n    // third: check workspace API entry header  for method config\n    entry = spl_wsRef ( input, apiRefUri );\n    if ( entry && entry.headers ) {\n        result = spl_rcRef ( entry.headers, methodRef );\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\n    }\n    if ( !( result === undefined ) ) return result;\n\n    // no API default for full method property set\n    if ( key === undefined ) return result; // no default\n\n    // fourth: check execution header for API config (default)\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\n    if ( !( result === undefined ) ) return result;\n    \n    // fifth: check workspace API entry header for API config (default)\n    entry = spl_wsRef ( input, apiRefUri );\n    if ( entry && entry.headers ) {\n        result = spl_rcRef ( entry.headers, apiRef );\n        if ( !( result === undefined ) ) result = result[key];\n    }\n    return result;\n}\nexports.config = spl_config;\n\n// get execution context properties\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\nexports.context = spl_context;\n\n// get request properties only ( spl/execute/request )\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\nexports.request = spl_request;\n\n// set current action specific properties \nfunction spl_setAction ( input, key, value ) {\n    var action;\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\n    else action = spl_context ( input, \"action\" );\n    return spl_setConfig ( input, action, key, value );\n}\nexports.setAction = spl_setAction;\n\n// set method / api specific properties \nfunction spl_setConfig ( input, action, key, value ) {\n    action = action.replaceAll ( \"/\", \".\" );\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\n}\nexports.setConfig = spl_setConfig;\n\n// set execution context properties\nfunction spl_setContext ( input, key, value ) { \n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.execute\", value ); \n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \n}\nexports.setContext = spl_setContext;\n\n// set request properties only ( spl/execute/request )\nfunction spl_setRequest ( input, key, value ) {\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.request\", value );\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\n}\nexports.setRequest = spl_setRequest;\n\n// Complete request\nexports.completed = function ( input ) {\n    var action;\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) {\n        action = spl_request ( input, \"action\" );\n        spl_setRequest ( input, \"status\", \"completed\" );\n    } else {\n        action = spl_context ( input, \"action\" );\n        spl_setContext ( input, \"action\", \"spl/execute/set-next\" );\n    }\n    spl_rcDelete ( input.headers, action.replaceAll ( \"/\", \".\" ) );\n}\n\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\nexports.fURI = function ( ... args ) { \n    args[args.length-1] = args[args.length-1].replaceAll ( \".\", \"_\" );\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \"\") result.push(args[i]);;\n    return result.join ( \"/\" );\n}\n\n// random UUID generation\nfunction generateUUID() { return randomUUID(); }\nexports.generateUUID = generateUUID;\n\n// wsAction sets an action for the execution context\nexports.gotoExecute = function ( input, action, args )\n{\n    var parts = action.split ( \"/\" );\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\n    spl_setRequest ( input, `${parts[1]}_next`, action );\n    spl_setRequest ( input, \"status\", parts[1] );\n    spl_setRequest ( input, \"repeat\", false );\n    spl_request ( input, \"action\" ); //.split ( \"/\" );\n    spl_rcDelete ( input.headers, spl_request ( input, \"action\" ).replaceAll ( \"/\", \".\" ) );\n}\n\n// add to execution history\nexports.history = function ( input, activity )\n{\n    const action = spl_request ( input, \"action\" ); \n    var message = [ action, spl_context ( input, \"action\" ), activity ];\n    var history = spl_context ( input, \"history\" );\n    if ( history === undefined ) history = spl_setContext ( input, \"history\", [] );\n    history.push ( message );\n    var consoleProgress = spl_context ( input, \"consoleProgress\" );\n    if ( consoleProgress && consoleProgress != action )\n    {\n        consoleProgress = action;\n        console.log ( ` > ${consoleProgress}` );\n        spl_setContext ( input, \"consoleProgress\", consoleProgress );\n    }\n    if ( activity.substring ( 0, 5 ) == \"ERROR\" ) console.error ( message.join ( \" - \" ) );\n    else if ( spl_context ( input, \"consoleMode\" ) != \"silent\" && activity.substring ( 0, 7 ) == \"WARNING\" ) console.error ( message.join ( \" - \" ) );\n}\n\n// easy functions to invoke actions\nexports.moduleAction = function (input, module)\n{\n    var moduleRoot = spl_context ( input, \"modules\" );\n    if ( moduleRoot === undefined ) moduleRoot = \"modules\";\n    var moduleOverlay = spl_context ( input, \"moduleOverlay\" );\n    if ( moduleOverlay )\n        for ( var i = 0; i < moduleOverlay.length; i++ )\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\n    return require ( `${ spl_context ( input, \"cwd\" )}/${moduleRoot}/${module}`).default ( input );\n}\n\n// gets a deep clone of a keyvalue in input\nfunction spl_rcDelete (reference, key)\n{ \n    const keys = key.split(\".\");\n    for( i = 0; i < keys.length - 1; i++)\n    {\n        if(reference[keys[i]]==undefined) return;\n        reference = reference[keys[i]];\n    }\n    delete reference[keys[i]];\n}\nexports.rcDelete = spl_rcDelete;\n\n// gets a deep clone of a keyvalue in input\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\nexports.rcGet = spl_rcGet;\n\n// gets a reference to a keyvalue in input\nfunction spl_rcRef (reference, key)\n{ \n    const keys = key.split(\".\");\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\n    return reference;\n}\nexports.rcRef = spl_rcRef;\n\n// Sets a value of a keyvalue in input\nfunction spl_rcSet (reference, key, value)\n{ \n    const keys = key.split(\".\");\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \n    reference[keys[i]] = value;\n    return reference[keys[i]]\n}\nexports.rcSet = spl_rcSet;\n\n// Complete request\nexports.throwError = function ( input, message )\n{\n    spl_setContext ( input, \"action\", \"spl/error/catch\" );\n    spl_setConfig ( input, \"spl/error/catch\", \"message\", message );\n}\n\n// construct a forward slash path for platform internal use\nexports.URI = function ( ...args ) { \n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \"\" ) result.push ( args[i] );\n    return result.join ( \"/\" );\n}\n\n// wsExists checks the presence of a property and loads it when not\nexports.wsExists = function ( input, key, action, args, repeat ) {\n    const parts = action.split ( \"/\" );\n    if( spl_wsRef ( input, key ) === undefined ) {\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\n        else spl_rcSet ( input.headers, parts.join ( \".\" ), [args] );\n        spl_setRequest ( input, `${parts[1]}_next`, action );\n        spl_setRequest ( input, \"status\", parts[1] );\n        spl_setRequest ( input, \"repeat\", repeat );\n        return false;\n    }\n    return true;\n}\n\n// wsGet returns a deep clone of a keyvalue in input.value.\nexports.wsGet = function ( input, key ) { \n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) ) ); \n}\n\n// wsRef returns a reference to a keyvalue in input.value.\nfunction spl_wsRef (input, key) \n{ \n    const parts = key.split ( \".\" );\n    var value = spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) );\n    if ( typeof value == \"string\" && !( \"spl/blob spl/package\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\n    return value;\n}\nexports.wsRef = spl_wsRef;\n\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\nexports.wsSet = function (input, key, value)\n{ \n    const expandedKey = key.replaceAll ( \".\", \".value.\" );\n    const current = spl_rcRef ( input.value, expandedKey );\n    if( !( current === undefined ) ) {\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\n        archive.push(current);\n    }\n    spl_rcSet ( input.value, expandedKey, value );\n}",
    "/test-boot/modules/usr/usr.js": "//  name        Test Boot Auxiliary Functions\r\n//  URI         usr/usr\r\n//  type        Auxiliary Library\r\n//  description Library of auxiliary methods for boot app testing\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Verify file patterns in a directory\r\nexports.verifyFilePatterns = function (input, spl, targetPath) {\r\n    spl.history(input, `Checking file patterns in ${targetPath}`);\r\n    \r\n    try {\r\n        const files = fs.readdirSync(targetPath);\r\n        \r\n        let testResults = {\r\n            totalFiles: files.length,\r\n            batchFiles: 0,\r\n            txtFiles: 0,\r\n            otherFiles: 0,\r\n            txtFileList: [],\r\n            passed: true\r\n        };\r\n        \r\n        // Analyze file patterns\r\n        files.forEach(file => {\r\n            if (file.endsWith('.batch')) {\r\n                testResults.batchFiles++;\r\n            } else if (file.endsWith('.txt')) {\r\n                testResults.txtFiles++;\r\n                testResults.txtFileList.push(file);\r\n                testResults.passed = false;\r\n            } else {\r\n                testResults.otherFiles++;\r\n            }\r\n        });\r\n        \r\n        return testResults;\r\n        \r\n    } catch (error) {\r\n        spl.history(input, `ERROR - failed to read directory ${targetPath}: ${error.message}`);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Check if directory exists\r\nexports.directoryExists = function (input, spl, dirPath) {\r\n    try {\r\n        const stats = fs.statSync(dirPath);\r\n        return stats.isDirectory();\r\n    } catch (error) {\r\n        spl.history(input, `Directory check failed for ${dirPath}: ${error.message}`);\r\n        return false;\r\n    }\r\n}\r\n\r\n// Get absolute path relative to SPlectrum install root\r\nexports.getBootPath = function (input, spl) {\r\n    const cwd = spl.context(input, \"cwd\");\r\n    return path.join(cwd, 'apps/boot/batches');\r\n}",
    "/test-boot/modules/usr/verify-boot-file-patterns.js": "//  name        Verify Boot App File Patterns\r\n//  URI         usr/verify-boot-file-patterns\r\n//  type        Test Method\r\n//  description Verifies that boot app source contains only .batch files, no .txt files\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst spl = require(\"../spl.js\")\r\nconst usr = require(\"./usr.js\")\r\n///////////////////////////////////////////////////////////////////////////////\r\nexports.default = function usr_verify_boot_file_patterns(input) {\r\n    spl.history(input, `Starting boot app file pattern verification`);\r\n    \r\n    // Get boot app batches path\r\n    const targetPath = usr.getBootPath(input, spl);\r\n    \r\n    // Verify directory exists\r\n    if (!usr.directoryExists(input, spl, targetPath)) {\r\n        spl.throwError(input, `Boot app batches directory not found: ${targetPath}`);\r\n        return;\r\n    }\r\n    \r\n    // Verify file patterns\r\n    const testResults = usr.verifyFilePatterns(input, spl, targetPath);\r\n    \r\n    if (testResults === null) {\r\n        spl.throwError(input, `Failed to analyze file patterns in ${targetPath}`);\r\n        return;\r\n    }\r\n    \r\n    // Report results using direct console calls\r\n    if (testResults.passed) {\r\n        console.log(`✓ Boot app file patterns correct`);\r\n    } else {\r\n        console.error(`✗ Boot app contains ${testResults.txtFiles} .txt files: ${testResults.txtFileList.join(', ')}`);\r\n    }\r\n    \r\n    // Store test results in workspace\r\n    spl.wsSet(input, 'test/boot-file-patterns/results', { \r\n        headers: { spl: { test: { status: testResults.passed ? 'passed' : 'failed' } } },\r\n        value: testResults \r\n    });\r\n    \r\n    spl.history(input, `Boot app file pattern verification completed: ${testResults.passed ? 'PASSED' : 'FAILED'}`);\r\n    spl.completed(input);\r\n}",
    "/test-boot/modules/usr/verify-boot-file-patterns_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"top\" : [\r\n            { \"header\": \"Boot App File Pattern Verification\" },\r\n            { \"content\": \"Verifies that boot app source contains only .batch files, no .txt files.\" }\r\n        ],\r\n        \"header\": [\r\n            { \"content\": \"Checks spl/apps/boot/batches/ directory for proper file patterns.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl usr/verify-boot-file-patterns}\" }\r\n        ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}",
    "/test-boot/modules/usr_arguments.json": "{}",
    "/test-boot/scripts/": {},
    "/test-boot/spl": "#!/bin/bash\r\nnode ./spl.js $@",
    "/test-boot/spl.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst appRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = {   action: \"spl/execute/initialise\", consoleProgress: \"start\",  consoleMode: \"standard\", // silent, standard, warning, verbose, debug\r\n                    runtimeMode: \"silent\", cwd: splRoot, session: session, modules: \"../modules\", moduleOverlay: [{ prefix: \"usr\", moduleRoot: `${appRoot}/modules` }], appRoot: appRoot, TTL: 100 };\r\nconst action = \"spl/app/process\";\r\nconst batch = commandString;\r\nconst config = { appRoot: appRoot, batch: batch };\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, action, null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );"
  }
}