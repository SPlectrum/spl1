{
  "headers": {
    "spl": {
      "package": {
        "name": "apps_model.json"
      }
    }
  },
  "value": {
    "/model/batches/": {},
    "/model/data/": {},
    "/model/modules/arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"top\" : [\r\n            { \"header\": \"SPlectrum Test App\" },\r\n            { \"content\": \"A client used to test the current package functionaltiy.\" }\r\n        ],\r\n        \"header\": [\r\n            { \"content\": \"Overview 1.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <options> <package>}\" }\r\n        ],\r\n        \"bottom\": [ \r\n            { \"content\": \"Project home: {underline https://github.com/SPlectrum/spl}\" } ]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"test\", \"alias\": \"t\", \"type\": \"Boolean\", \"description\": \"test - parse commands but do not execute.\", \"typeLabel\": \"flag\" }, \r\n        { \"name\": \"steps\", \"alias\": \"s\", \"type\": \"Number\", \"description\": \"TTL of the command execution.\"},\r\n        { \"name\": \"verbose\", \"alias\": \"v\", \"type\": \"Boolean\", \"description\": \"Do verbose output on completion.\"},\r\n        { \"name\": \"debug\", \"alias\": \"d\", \"type\": \"Boolean\", \"description\": \"Do debug output on completion.\"}\r\n    ]\r\n}\r\n",
    "/model/modules/spl.js": "//  name        SPL Package Useful Functions\r\n//  URI         spl/spl\r\n//  type        Auxiliary Library\r\n//  description Library of auxiliary methods at package level\r\n//              It contains methods to invoke actions, set properties and\r\n//              interacts with the workspace.\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst { randomUUID } = require('crypto');\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Gets a configuration value associated with the action currently being executed\r\nfunction spl_action ( input, key )\r\n{\r\n    // get the current action\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_config ( input, action, key );\r\n}\r\nexports.action = spl_action;\r\n\r\n// Gets a configuration value for the specified action\r\nfunction spl_config ( input, action, key )\r\n{\r\n    // split the current action ( request or execute )\r\n    var parts = parts = action.split ( \"/\" ), result, entry;\r\n    const apiRef = `${parts[0]}.${parts[1]}`;\r\n    const apiRefUri = `${parts[0]}/${parts[1]}`;\r\n    const methodRef = `${parts[0]}.${parts[1]}.${parts[2]}`;\r\n    const methodRefUri = action;\r\n\r\n    // first: check execution header for method config\r\n    if ( key === undefined ) result = spl_rcRef ( input.headers, methodRef );\r\n    else result = spl_rcRef ( input.headers, `${methodRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // second: check workspace method entry header for method config\r\n    entry = spl_wsRef ( input, methodRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // third: check workspace API entry header  for method config\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, methodRef );\r\n        if ( !( result === undefined || key === undefined ) ) result = result[key];\r\n    }\r\n    if ( !( result === undefined ) ) return result;\r\n\r\n    // no API default for full method property set\r\n    if ( key === undefined ) return result; // no default\r\n\r\n    // fourth: check execution header for API config (default)\r\n    result = spl_rcRef ( input.headers, `${apiRef}.${key}` );\r\n    if ( !( result === undefined ) ) return result;\r\n    \r\n    // fifth: check workspace API entry header for API config (default)\r\n    entry = spl_wsRef ( input, apiRefUri );\r\n    if ( entry && entry.headers ) {\r\n        result = spl_rcRef ( entry.headers, apiRef );\r\n        if ( !( result === undefined ) ) result = result[key];\r\n    }\r\n    return result;\r\n}\r\nexports.config = spl_config;\r\n\r\n// get execution context properties\r\nfunction spl_context ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.execute : input.headers.spl.execute[key] ); }\r\nexports.context = spl_context;\r\n\r\n// get request properties only ( spl/execute/request )\r\nfunction spl_request ( input, key ) { return ( ( key === undefined ) ? input.headers.spl.request : input.headers.spl.request[key] ); }\r\nexports.request = spl_request;\r\n\r\n// set current action specific properties \r\nfunction spl_setAction ( input, key, value ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) action = spl_request ( input, \"action\");\r\n    else action = spl_context ( input, \"action\" );\r\n    return spl_setConfig ( input, action, key, value );\r\n}\r\nexports.setAction = spl_setAction;\r\n\r\n// set method / api specific properties \r\nfunction spl_setConfig ( input, action, key, value ) {\r\n    action = action.replaceAll ( \"/\", \".\" );\r\n    if ( key === null ) spl_rcSet ( input.headers, action, value );\r\n    else  spl_rcSet ( input.headers, `${action}.${key}`, value );\r\n}\r\nexports.setConfig = spl_setConfig;\r\n\r\n// set execution context properties\r\nfunction spl_setContext ( input, key, value ) { \r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.execute\", value ); \r\n    else return spl_rcSet ( input, `headers.spl.execute.${key}`, value ); \r\n}\r\nexports.setContext = spl_setContext;\r\n\r\n// set request properties only ( spl/execute/request )\r\nfunction spl_setRequest ( input, key, value ) {\r\n    if ( key === null ) return spl_rcSet ( input, \"headers.spl.request\", value );\r\n    else spl_rcSet ( input, `headers.spl.request.${key}`, value );\r\n}\r\nexports.setRequest = spl_setRequest;\r\n\r\n// Complete request\r\nexports.completed = function ( input ) {\r\n    var action;\r\n    if ( spl_context ( input, \"action\" ) === \"spl/execute/next\" ) {\r\n        action = spl_request ( input, \"action\" );\r\n        spl_setRequest ( input, \"status\", \"completed\" );\r\n    } else {\r\n        action = spl_context ( input, \"action\" );\r\n        spl_setContext ( input, \"action\", \"spl/execute/set-next\" );\r\n    }\r\n    spl_rcDelete ( input.headers, action.replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// construct a forward slash path with filename for platform internal use - dot converted to underscore\r\nexports.fURI = function ( ... args ) { \r\n    args[args.length-1] = args[args.length-1].replaceAll ( \".\", \"_\" );\r\n    var result = []; for(var i=0; i<args.length; i++) if(args[i] != \"\") result.push(args[i]);;\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// random UUID generation\r\nfunction generateUUID() { return randomUUID(); }\r\nexports.generateUUID = generateUUID;\r\n\r\n// wsAction sets an action for the execution context\r\nexports.gotoExecute = function ( input, action, args )\r\n{\r\n    var parts = action.split ( \"/\" );\r\n    if ( args != undefined ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n    spl_setRequest ( input, `${parts[1]}_next`, action );\r\n    spl_setRequest ( input, \"status\", parts[1] );\r\n    spl_setRequest ( input, \"repeat\", false );\r\n    spl_request ( input, \"action\" ); //.split ( \"/\" );\r\n    spl_rcDelete ( input.headers, spl_request ( input, \"action\" ).replaceAll ( \"/\", \".\" ) );\r\n}\r\n\r\n// add to execution history\r\nexports.history = function ( input, activity )\r\n{\r\n    const action = spl_request ( input, \"action\" ); \r\n    var message = [ action, spl_context ( input, \"action\" ), activity ];\r\n    var history = spl_context ( input, \"history\" );\r\n    if ( history === undefined ) history = spl_setContext ( input, \"history\", [] );\r\n    history.push ( message );\r\n    var consoleProgress = spl_context ( input, \"consoleProgress\" );\r\n    if ( consoleProgress && consoleProgress != action )\r\n    {\r\n        consoleProgress = action;\r\n        console.log ( ` > ${consoleProgress}` );\r\n        spl_setContext ( input, \"consoleProgress\", consoleProgress );\r\n    }\r\n    if ( activity.substring ( 0, 5 ) == \"ERROR\" ) console.error ( message.join ( \" - \" ) );\r\n    else if ( spl_context ( input, \"consoleMode\" ) != \"silent\" && activity.substring ( 0, 7 ) == \"WARNING\" ) console.error ( message.join ( \" - \" ) );\r\n}\r\n\r\n// easy functions to invoke actions\r\nexports.moduleAction = function (input, module)\r\n{\r\n    var moduleRoot = spl_context ( input, \"modules\" );\r\n    if ( moduleRoot === undefined ) moduleRoot = \"modules\";\r\n    var moduleOverlay = spl_context ( input, \"moduleOverlay\" );\r\n    if ( moduleOverlay )\r\n        for ( var i = 0; i < moduleOverlay.length; i++ )\r\n            if ( module.indexOf ( moduleOverlay[i].prefix ) == 0 )\r\n                { moduleRoot = moduleOverlay[i].moduleRoot; i = moduleOverlay.length; }\r\n    return require ( `${ spl_context ( input, \"cwd\" )}/${moduleRoot}/${module}`).default ( input );\r\n}\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcDelete (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length - 1; i++)\r\n    {\r\n        if(reference[keys[i]]==undefined) return;\r\n        reference = reference[keys[i]];\r\n    }\r\n    delete reference[keys[i]];\r\n}\r\nexports.rcDelete = spl_rcDelete;\r\n\r\n// gets a deep clone of a keyvalue in input\r\nfunction spl_rcGet (reference, key) { return structuredClone ( spl_rcRef ( reference, key ) ); }\r\nexports.rcGet = spl_rcGet;\r\n\r\n// gets a reference to a keyvalue in input\r\nfunction spl_rcRef (reference, key)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length; i++) { if ( reference[keys[i]] === undefined ) return undefined; reference = reference[keys[i]]; }\r\n    return reference;\r\n}\r\nexports.rcRef = spl_rcRef;\r\n\r\n// Sets a value of a keyvalue in input\r\nfunction spl_rcSet (reference, key, value)\r\n{ \r\n    const keys = key.split(\".\");\r\n    for( i = 0; i < keys.length-1; i++) { if( reference[keys[i]] === undefined ) reference[keys[i]] = {}; reference = reference[keys[i]]; } \r\n    reference[keys[i]] = value;\r\n    return reference[keys[i]]\r\n}\r\nexports.rcSet = spl_rcSet;\r\n\r\n// Complete request\r\nexports.throwError = function ( input, message )\r\n{\r\n    spl_setContext ( input, \"action\", \"spl/error/catch\" );\r\n    spl_setConfig ( input, \"spl/error/catch\", \"message\", message );\r\n}\r\n\r\n// construct a forward slash path for platform internal use\r\nexports.URI = function ( ...args ) { \r\n    var result = []; for ( var i = 0; i < args.length; i++ ) if ( args[i] != \"\" ) result.push ( args[i] );\r\n    return result.join ( \"/\" );\r\n}\r\n\r\n// wsExists checks the presence of a property and loads it when not\r\nexports.wsExists = function ( input, key, action, args, repeat ) {\r\n    const parts = action.split ( \"/\" );\r\n    if( spl_wsRef ( input, key ) === undefined ) {\r\n        if( Array.isArray ( args ) ) spl_rcSet ( input.headers, parts.join ( \".\" ), args );\r\n        else spl_rcSet ( input.headers, parts.join ( \".\" ), [args] );\r\n        spl_setRequest ( input, `${parts[1]}_next`, action );\r\n        spl_setRequest ( input, \"status\", parts[1] );\r\n        spl_setRequest ( input, \"repeat\", repeat );\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// wsGet returns a deep clone of a keyvalue in input.value.\r\nexports.wsGet = function ( input, key ) { \r\n    return structuredClone ( spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) ) ); \r\n}\r\n\r\n// wsRef returns a reference to a keyvalue in input.value.\r\nfunction spl_wsRef (input, key) \r\n{ \r\n    const parts = key.split ( \".\" );\r\n    var value = spl_rcRef ( input.value, key.replaceAll ( \".\", \".value.\" ) );\r\n    if ( typeof value == \"string\" && !( \"spl/blob spl/package\").includes ( parts[0] ) ) value = spl_wsRef ( input, value );\r\n    return value;\r\n}\r\nexports.wsRef = spl_wsRef;\r\n\r\n// wsSet property sets a key in input.value but archives the existing keyvalue in an array.\r\nexports.wsSet = function (input, key, value)\r\n{ \r\n    const expandedKey = key.replaceAll ( \".\", \".value.\" );\r\n    const current = spl_rcRef ( input.value, expandedKey );\r\n    if( !( current === undefined ) ) {\r\n        var archive = spl_rcRef ( input.value, `${expandedKey}/archive` );\r\n        if ( archive === undefined ) archive = spl_rcSet ( input.value, `${expandedKey}/archive`, [] );\r\n        archive.push(current);\r\n    }\r\n    spl_rcSet ( input.value, expandedKey, value );\r\n}\r\n",
    "/model/modules/usr/": {},
    "/model/modules/usr_arguments.json": "{\r\n    \"headers\": \r\n    {\r\n        \"header\": \r\n        [\r\n            { \"header\": \"usr Package\" },\r\n            { \"content\": \"Implements the API functionality of the SPlectrum app.\" },\r\n            { \"content\": \"{bold syntax}: {italic ./spl <appOpts> <package> <options> <api>}\" }\r\n]\r\n    },\r\n    \"value\": \r\n    [ \r\n        { \"name\": \"help\", \"alias\": \"h\", \"type\": \"Boolean\", \"description\": \"show help information\", \"typeLabel\": \"flag\" }\r\n    ]\r\n}\r\n",
    "/model/scripts/": {},
    "/model/spl": "#!/bin/bash\nnode ./spl.js $@\n",
    "/model/spl.js": "const spl = require(\"../../../modules/spl/spl.js\");\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Set SPlectrum and client root directory, extract command string\r\nvar root = process.cwd().split(\"/\");\r\nif (root.length === 1 ) root = root[0].split(`\\\\`);\r\nconst splRoot = root.slice(0,root.length-2).join(\"/\");\r\nconst session = root[root.length-1];\r\nconst appRoot = root.slice(root.length - 2).join(\"/\")\r\nconst commandString = process.argv.slice(2);\r\n///////////////////////////////////////////////////////////////////////////////\r\nconst context = {   action: \"spl/execute/initialise\", consoleProgress: \"start\",  consoleMode: \"standard\", // silent, standard, warning, verbose, debug\r\n                    runtimeMode: \"silent\", cwd: splRoot, session: session, modules: \"../modules\", moduleOverlay: [{ prefix: \"usr\", moduleRoot: `${appRoot}/modules` }], appRoot: appRoot, TTL: 100 };\r\nconst action = \"spl/app/process\";\r\nconst batch = commandString;\r\nconst config = { appRoot: appRoot, batch: batch };\r\n///////////////////////////////////////////////////////////////////////////////\r\nvar command = { headers: {}, value: {} }\r\nspl.setContext ( command, null, context );\r\nspl.setRequest ( command, \"action\", action );\r\nspl.setConfig ( command, action, null, config );\r\n///////////////////////////////////////////////////////////////////////////////\r\nspl.moduleAction( command, \"spl/execute/execute\" );\r\n"
  }
}